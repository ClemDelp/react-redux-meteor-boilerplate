{"metadata":{"usedHelpers":[],"marked":[],"modules":{"imports":[],"exports":{"exported":[],"specifiers":[]}}},"options":{"filename":"/packages/ddp-server/livedata_server_tests.js","filenameRelative":"/packages/ddp-server/livedata_server_tests.js","env":{},"retainLines":false,"highlightCode":true,"suppressDeprecationMessages":false,"presets":[],"plugins":[[[],{"polyfill":false}],[[],{"allowTopLevelThis":true,"strict":false,"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],{"loose":true}],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null]],"ignore":[],"code":true,"metadata":true,"ast":false,"comments":true,"compact":false,"minified":false,"sourceMap":true,"sourceMaps":true,"sourceMapTarget":"/packages/ddp-server/livedata_server_tests.js.map","sourceFileName":"/packages/ddp-server/livedata_server_tests.js","babelrc":false,"sourceType":"module","moduleIds":false,"passPerPreset":false,"basename":"livedata_server_tests"},"ignored":false,"code":"var Fiber = Npm.require('fibers');\n\nTinytest.addAsync(\"livedata server - connectionHandle.onClose()\", function (test, onComplete) {\n  makeTestConnection(test, function (clientConn, serverConn) {\n    // On the server side, wait for the connection to be closed.\n    serverConn.onClose(function () {\n      test.isTrue(true);\n      // Add a new onClose after the connection is already\n      // closed. See that it fires.\n      serverConn.onClose(function () {\n        onComplete();\n      });\n    });\n    // Close the connection from the client.\n    clientConn.disconnect();\n  }, onComplete);\n});\n\nTinytest.addAsync(\"livedata server - connectionHandle.close()\", function (test, onComplete) {\n  makeTestConnection(test, function (clientConn, serverConn) {\n    // Wait for the connection to be closed from the server side.\n    simplePoll(function () {\n      return !clientConn.status().connected;\n    }, onComplete, function () {\n      test.fail(\"timeout waiting for the connection to be closed on the server side\");\n      onComplete();\n    });\n\n    // Close the connection from the server.\n    serverConn.close();\n  }, onComplete);\n});\n\ntestAsyncMulti(\"livedata server - onConnection doesn't get callback after stop.\", [function (test, expect) {\n  var afterStop = false;\n  var expectStop1 = expect();\n  var stopHandle1 = Meteor.onConnection(function (conn) {\n    stopHandle2.stop();\n    stopHandle1.stop();\n    afterStop = true;\n    // yield to the event loop for a moment to see that no other calls\n    // to listener2 are called.\n    Meteor.setTimeout(expectStop1, 10);\n  });\n  var stopHandle2 = Meteor.onConnection(function (conn) {\n    test.isFalse(afterStop);\n  });\n\n  // trigger a connection\n  var expectConnection = expect();\n  makeTestConnection(test, function (clientConn, serverConn) {\n    // Close the connection from the client.\n    clientConn.disconnect();\n    expectConnection();\n  }, expectConnection);\n}]);\n\nMeteor.methods({\n  livedata_server_test_inner: function livedata_server_test_inner() {\n    return this.connection.id;\n  },\n\n  livedata_server_test_outer: function livedata_server_test_outer() {\n    return Meteor.call('livedata_server_test_inner');\n  }\n});\n\nTinytest.addAsync(\"livedata server - connection in method invocation\", function (test, onComplete) {\n  makeTestConnection(test, function (clientConn, serverConn) {\n    var res = clientConn.call('livedata_server_test_inner');\n    test.equal(res, serverConn.id);\n    clientConn.disconnect();\n    onComplete();\n  }, onComplete);\n});\n\nTinytest.addAsync(\"livedata server - connection in nested method invocation\", function (test, onComplete) {\n  makeTestConnection(test, function (clientConn, serverConn) {\n    var res = clientConn.call('livedata_server_test_outer');\n    test.equal(res, serverConn.id);\n    clientConn.disconnect();\n    onComplete();\n  }, onComplete);\n});\n\n// connectionId -> callback\nvar onSubscription = {};\n\nMeteor.publish(\"livedata_server_test_sub\", function (connectionId) {\n  var callback = onSubscription[connectionId];\n  if (callback) callback(this);\n  this.stop();\n});\n\nTinytest.addAsync(\"livedata server - connection in publish function\", function (test, onComplete) {\n  makeTestConnection(test, function (clientConn, serverConn) {\n    onSubscription[serverConn.id] = function (subscription) {\n      delete onSubscription[serverConn.id];\n      test.equal(subscription.connection.id, serverConn.id);\n      clientConn.disconnect();\n      onComplete();\n    };\n    clientConn.subscribe(\"livedata_server_test_sub\", serverConn.id);\n  });\n});\n\nMeteor.methods({\n  testResolvedPromise: function testResolvedPromise(arg) {\n    var invocation1 = DDP._CurrentInvocation.get();\n    return new Promise.resolve(arg).then(function (result) {\n      var invocation2 = DDP._CurrentInvocation.get();\n      // This equality holds because Promise callbacks are bound to the\n      // dynamic environment where .then was called.\n      if (invocation1 !== invocation2) {\n        throw new Meteor.Error(\"invocation mismatch\");\n      }\n      return result + \" after waiting\";\n    });\n  },\n  testRejectedPromise: function testRejectedPromise(arg) {\n    return new Promise.resolve(arg).then(function (result) {\n      throw new Meteor.Error(result + \" raised Meteor.Error\");\n    });\n  }\n});\n\nTinytest.addAsync(\"livedata server - waiting for Promise\", function (test, onComplete) {\n  return makeTestConnection(test, function (clientConn, serverConn) {\n    test.equal(clientConn.call(\"testResolvedPromise\", \"clientConn.call\"), \"clientConn.call after waiting\");\n\n    var clientCallPromise = new Promise(function (resolve, reject) {\n      return clientConn.call(\"testResolvedPromise\", \"clientConn.call with callback\", function (error, result) {\n        return error ? reject(error) : resolve(result);\n      });\n    });\n\n    var clientCallRejectedPromise = new Promise(function (resolve) {\n      clientConn.call(\"testRejectedPromise\", \"with callback\", function (error, result) {\n        return resolve(error.message);\n      });\n    });\n\n    Promise.all([clientCallPromise, clientCallRejectedPromise]).then(function (results) {\n      return test.equal(results, [\"clientConn.call with callback after waiting\", \"[with callback raised Meteor.Error]\"]);\n    }, function (error) {\n      return test.fail(error);\n    }).then(onComplete);\n  });\n});","ast":null,"map":{"version":3,"sources":["/packages/ddp-server/livedata_server_tests.js"],"names":[],"mappings":"AAAA,IAAI,QAAQ,IAAI,OAAJ,CAAY,QAAZ,CAAZ;;AAGA,SAAS,QAAT,CACE,8CADF,EAEE,UAAU,IAAV,EAAgB,UAAhB,EAA4B;AAC1B,qBACE,IADF,EAEE,UAAU,UAAV,EAAsB,UAAtB,EAAkC;;AAEhC,eAAW,OAAX,CAAmB,YAAY;AAC7B,WAAK,MAAL,CAAY,IAAZ;;;AAGA,iBAAW,OAAX,CAAmB,YAAY;AAC7B;AACD,OAFD;AAGD,KAPD;;AASA,eAAW,UAAX;AACD,GAdH,EAeE,UAfF;AAiBD,CApBH;;AAuBA,SAAS,QAAT,CACE,4CADF,EAEE,UAAU,IAAV,EAAgB,UAAhB,EAA4B;AAC1B,qBACE,IADF,EAEE,UAAU,UAAV,EAAsB,UAAtB,EAAkC;;AAEhC,eACE,YAAY;AACV,aAAO,CAAE,WAAW,MAAX,GAAoB,SAA7B;AACD,KAHH,EAIE,UAJF,EAKE,YAAY;AACV,WAAK,IAAL,CAAU,oEAAV;AACA;AACD,KARH;;;AAYA,eAAW,KAAX;AACD,GAjBH,EAkBE,UAlBF;AAoBD,CAvBH;;AA2BA,eACE,iEADF,EAEE,CAAC,UAAU,IAAV,EAAgB,MAAhB,EAAwB;AACvB,MAAI,YAAY,KAAhB;AACA,MAAI,cAAc,QAAlB;AACA,MAAI,cAAc,OAAO,YAAP,CAAoB,UAAU,IAAV,EAAgB;AACpD,gBAAY,IAAZ;AACA,gBAAY,IAAZ;AACA,gBAAY,IAAZ;;;AAGA,WAAO,UAAP,CAAkB,WAAlB,EAA+B,EAA/B;AACD,GAPiB,CAAlB;AAQA,MAAI,cAAc,OAAO,YAAP,CAAoB,UAAU,IAAV,EAAgB;AACpD,SAAK,OAAL,CAAa,SAAb;AACD,GAFiB,CAAlB;;;AAKA,MAAI,mBAAmB,QAAvB;AACA,qBACE,IADF,EAEE,UAAU,UAAV,EAAsB,UAAtB,EAAkC;;AAEhC,eAAW,UAAX;AACA;AACD,GANH,EAOE,gBAPF;AASD,CA1BD,CAFF;;AAgCA,OAAO,OAAP,CAAe;AACb,8BAA4B,sCAAY;AACtC,WAAO,KAAK,UAAL,CAAgB,EAAvB;AACD,GAHY;;AAKb,8BAA4B,sCAAY;AACtC,WAAO,OAAO,IAAP,CAAY,4BAAZ,CAAP;AACD;AAPY,CAAf;;AAWA,SAAS,QAAT,CACE,mDADF,EAEE,UAAU,IAAV,EAAgB,UAAhB,EAA4B;AAC1B,qBACE,IADF,EAEE,UAAU,UAAV,EAAsB,UAAtB,EAAkC;AAChC,QAAI,MAAM,WAAW,IAAX,CAAgB,4BAAhB,CAAV;AACA,SAAK,KAAL,CAAW,GAAX,EAAgB,WAAW,EAA3B;AACA,eAAW,UAAX;AACA;AACD,GAPH,EAQE,UARF;AAUD,CAbH;;AAiBA,SAAS,QAAT,CACE,0DADF,EAEE,UAAU,IAAV,EAAgB,UAAhB,EAA4B;AAC1B,qBACE,IADF,EAEE,UAAU,UAAV,EAAsB,UAAtB,EAAkC;AAChC,QAAI,MAAM,WAAW,IAAX,CAAgB,4BAAhB,CAAV;AACA,SAAK,KAAL,CAAW,GAAX,EAAgB,WAAW,EAA3B;AACA,eAAW,UAAX;AACA;AACD,GAPH,EAQE,UARF;AAUD,CAbH;;;AAkBA,IAAI,iBAAiB,EAArB;;AAEA,OAAO,OAAP,CAAe,0BAAf,EAA2C,UAAU,YAAV,EAAwB;AACjE,MAAI,WAAW,eAAe,YAAf,CAAf;AACA,MAAI,QAAJ,EACE,SAAS,IAAT;AACF,OAAK,IAAL;AACD,CALD;;AAQA,SAAS,QAAT,CACE,kDADF,EAEE,UAAU,IAAV,EAAgB,UAAhB,EAA4B;AAC1B,qBACE,IADF,EAEE,UAAU,UAAV,EAAsB,UAAtB,EAAkC;AAChC,mBAAe,WAAW,EAA1B,IAAgC,UAAU,YAAV,EAAwB;AACtD,aAAO,eAAe,WAAW,EAA1B,CAAP;AACA,WAAK,KAAL,CAAW,aAAa,UAAb,CAAwB,EAAnC,EAAuC,WAAW,EAAlD;AACA,iBAAW,UAAX;AACA;AACD,KALD;AAMA,eAAW,SAAX,CAAqB,0BAArB,EAAiD,WAAW,EAA5D;AACD,GAVH;AAYD,CAfH;;AAkBA,OAAO,OAAP,CAAe;AACb,qBADa,+BACO,GADP,EACY;AACvB,QAAM,cAAc,IAAI,kBAAJ,CAAuB,GAAvB,EAApB;AACA,WAAO,IAAI,QAAQ,OAAZ,CAAoB,GAApB,EAAyB,IAAzB,CAA8B,kBAAU;AAC7C,UAAM,cAAc,IAAI,kBAAJ,CAAuB,GAAvB,EAApB;;;AAGA,UAAI,gBAAgB,WAApB,EAAiC;AAC/B,cAAM,IAAI,OAAO,KAAX,CAAiB,qBAAjB,CAAN;AACD;AACD,aAAO,SAAS,gBAAhB;AACD,KARM,CAAP;AASD,GAZY;AAcb,qBAda,+BAcO,GAdP,EAcY;AACvB,WAAO,IAAI,QAAQ,OAAZ,CAAoB,GAApB,EAAyB,IAAzB,CAA8B,kBAAU;AAC7C,YAAM,IAAI,OAAO,KAAX,CAAiB,SAAS,sBAA1B,CAAN;AACD,KAFM,CAAP;AAGD;AAlBY,CAAf;;AAqBA,SAAS,QAAT,CACE,uCADF,EAEE,UAAC,IAAD,EAAO,UAAP;AAAA,SAAsB,mBAAmB,IAAnB,EAAyB,UAAC,UAAD,EAAa,UAAb,EAA4B;AACzE,SAAK,KAAL,CACE,WAAW,IAAX,CAAgB,qBAAhB,EAAuC,iBAAvC,CADF,EAEE,+BAFF;;AAKA,QAAM,oBAAoB,IAAI,OAAJ,CACxB,UAAC,OAAD,EAAU,MAAV;AAAA,aAAqB,WAAW,IAAX,CACnB,qBADmB,EAEnB,+BAFmB,EAGnB,UAAC,KAAD,EAAQ,MAAR;AAAA,eAAmB,QAAQ,OAAO,KAAP,CAAR,GAAwB,QAAQ,MAAR,CAA3C;AAAA,OAHmB,CAArB;AAAA,KADwB,CAA1B;;AAQA,QAAM,4BAA4B,IAAI,OAAJ,CAAY,mBAAW;AACvD,iBAAW,IAAX,CACE,qBADF,EAEE,eAFF,EAGE,UAAC,KAAD,EAAQ,MAAR;AAAA,eAAmB,QAAQ,MAAM,OAAd,CAAnB;AAAA,OAHF;AAKD,KANiC,CAAlC;;AAQA,YAAQ,GAAR,CAAY,CACV,iBADU,EAEV,yBAFU,CAAZ,EAGG,IAHH,CAGQ;AAAA,aAAW,KAAK,KAAL,CAAW,OAAX,EAAoB,CACrC,6CADqC,EAErC,qCAFqC,CAApB,CAAX;AAAA,KAHR,EAMI;AAAA,aAAS,KAAK,IAAL,CAAU,KAAV,CAAT;AAAA,KANJ,EAOG,IAPH,CAOQ,UAPR;AAQD,GA9BqB,CAAtB;AAAA,CAFF","file":"/packages/ddp-server/livedata_server_tests.js.map","sourcesContent":["var Fiber = Npm.require('fibers');\n\n\nTinytest.addAsync(\n  \"livedata server - connectionHandle.onClose()\",\n  function (test, onComplete) {\n    makeTestConnection(\n      test,\n      function (clientConn, serverConn) {\n        // On the server side, wait for the connection to be closed.\n        serverConn.onClose(function () {\n          test.isTrue(true);\n          // Add a new onClose after the connection is already\n          // closed. See that it fires.\n          serverConn.onClose(function () {\n            onComplete();\n          });\n        });\n        // Close the connection from the client.\n        clientConn.disconnect();\n      },\n      onComplete\n    );\n  }\n);\n\nTinytest.addAsync(\n  \"livedata server - connectionHandle.close()\",\n  function (test, onComplete) {\n    makeTestConnection(\n      test,\n      function (clientConn, serverConn) {\n        // Wait for the connection to be closed from the server side.\n        simplePoll(\n          function () {\n            return ! clientConn.status().connected;\n          },\n          onComplete,\n          function () {\n            test.fail(\"timeout waiting for the connection to be closed on the server side\");\n            onComplete();\n          }\n        );\n\n        // Close the connection from the server.\n        serverConn.close();\n      },\n      onComplete\n    );\n  }\n);\n\n\ntestAsyncMulti(\n  \"livedata server - onConnection doesn't get callback after stop.\",\n  [function (test, expect) {\n    var afterStop = false;\n    var expectStop1 = expect();\n    var stopHandle1 = Meteor.onConnection(function (conn) {\n      stopHandle2.stop();\n      stopHandle1.stop();\n      afterStop = true;\n      // yield to the event loop for a moment to see that no other calls\n      // to listener2 are called.\n      Meteor.setTimeout(expectStop1, 10);\n    });\n    var stopHandle2 = Meteor.onConnection(function (conn) {\n      test.isFalse(afterStop);\n    });\n\n    // trigger a connection\n    var expectConnection = expect();\n    makeTestConnection(\n      test,\n      function (clientConn, serverConn) {\n        // Close the connection from the client.\n        clientConn.disconnect();\n        expectConnection();\n      },\n      expectConnection\n    );\n  }]\n);\n\n\nMeteor.methods({\n  livedata_server_test_inner: function () {\n    return this.connection.id;\n  },\n\n  livedata_server_test_outer: function () {\n    return Meteor.call('livedata_server_test_inner');\n  }\n});\n\n\nTinytest.addAsync(\n  \"livedata server - connection in method invocation\",\n  function (test, onComplete) {\n    makeTestConnection(\n      test,\n      function (clientConn, serverConn) {\n        var res = clientConn.call('livedata_server_test_inner');\n        test.equal(res, serverConn.id);\n        clientConn.disconnect();\n        onComplete();\n      },\n      onComplete\n    );\n  }\n);\n\n\nTinytest.addAsync(\n  \"livedata server - connection in nested method invocation\",\n  function (test, onComplete) {\n    makeTestConnection(\n      test,\n      function (clientConn, serverConn) {\n        var res = clientConn.call('livedata_server_test_outer');\n        test.equal(res, serverConn.id);\n        clientConn.disconnect();\n        onComplete();\n      },\n      onComplete\n    );\n  }\n);\n\n\n// connectionId -> callback\nvar onSubscription = {};\n\nMeteor.publish(\"livedata_server_test_sub\", function (connectionId) {\n  var callback = onSubscription[connectionId];\n  if (callback)\n    callback(this);\n  this.stop();\n});\n\n\nTinytest.addAsync(\n  \"livedata server - connection in publish function\",\n  function (test, onComplete) {\n    makeTestConnection(\n      test,\n      function (clientConn, serverConn) {\n        onSubscription[serverConn.id] = function (subscription) {\n          delete onSubscription[serverConn.id];\n          test.equal(subscription.connection.id, serverConn.id);\n          clientConn.disconnect();\n          onComplete();\n        };\n        clientConn.subscribe(\"livedata_server_test_sub\", serverConn.id);\n      }\n    );\n  }\n);\n\nMeteor.methods({\n  testResolvedPromise(arg) {\n    const invocation1 = DDP._CurrentInvocation.get();\n    return new Promise.resolve(arg).then(result => {\n      const invocation2 = DDP._CurrentInvocation.get();\n      // This equality holds because Promise callbacks are bound to the\n      // dynamic environment where .then was called.\n      if (invocation1 !== invocation2) {\n        throw new Meteor.Error(\"invocation mismatch\");\n      }\n      return result + \" after waiting\";\n    });\n  },\n\n  testRejectedPromise(arg) {\n    return new Promise.resolve(arg).then(result => {\n      throw new Meteor.Error(result + \" raised Meteor.Error\");\n    });\n  }\n});\n\nTinytest.addAsync(\n  \"livedata server - waiting for Promise\",\n  (test, onComplete) => makeTestConnection(test, (clientConn, serverConn) => {\n    test.equal(\n      clientConn.call(\"testResolvedPromise\", \"clientConn.call\"),\n      \"clientConn.call after waiting\"\n    );\n\n    const clientCallPromise = new Promise(\n      (resolve, reject) => clientConn.call(\n        \"testResolvedPromise\",\n        \"clientConn.call with callback\",\n        (error, result) => error ? reject(error) : resolve(result)\n      )\n    );\n\n    const clientCallRejectedPromise = new Promise(resolve => {\n      clientConn.call(\n        \"testRejectedPromise\",\n        \"with callback\",\n        (error, result) => resolve(error.message)\n      );\n    });\n\n    Promise.all([\n      clientCallPromise,\n      clientCallRejectedPromise,\n    ]).then(results => test.equal(results, [\n      \"clientConn.call with callback after waiting\",\n      \"[with callback raised Meteor.Error]\",\n    ]), error => test.fail(error))\n      .then(onComplete);\n  })\n);\n"]},"hash":"e5a002a79fbd1c1573a553db96e55a4e60000e58"}
