{"metadata":{"usedHelpers":[],"marked":[],"modules":{"imports":[],"exports":{"exported":[],"specifiers":[]}}},"options":{"filename":"/packages/ddp-server/writefence.js","filenameRelative":"/packages/ddp-server/writefence.js","env":{},"retainLines":false,"highlightCode":true,"suppressDeprecationMessages":false,"presets":[],"plugins":[[[],{"polyfill":false}],[[],{"allowTopLevelThis":true,"strict":false,"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],{"loose":true}],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null]],"ignore":[],"code":true,"metadata":true,"ast":false,"comments":true,"compact":false,"minified":false,"sourceMap":true,"sourceMaps":true,"sourceMapTarget":"/packages/ddp-server/writefence.js.map","sourceFileName":"/packages/ddp-server/writefence.js","babelrc":false,"sourceType":"module","moduleIds":false,"passPerPreset":false,"basename":"writefence"},"ignored":false,"code":"var path = Npm.require('path');\nvar Future = Npm.require(path.join('fibers', 'future'));\n\n// A write fence collects a group of writes, and provides a callback\n// when all of the writes are fully committed and propagated (all\n// observers have been notified of the write and acknowledged it.)\n//\nDDPServer._WriteFence = function () {\n  var self = this;\n\n  self.armed = false;\n  self.fired = false;\n  self.retired = false;\n  self.outstanding_writes = 0;\n  self.before_fire_callbacks = [];\n  self.completion_callbacks = [];\n};\n\n// The current write fence. When there is a current write fence, code\n// that writes to databases should register their writes with it using\n// beginWrite().\n//\nDDPServer._CurrentWriteFence = new Meteor.EnvironmentVariable();\n\n_.extend(DDPServer._WriteFence.prototype, {\n  // Start tracking a write, and return an object to represent it. The\n  // object has a single method, committed(). This method should be\n  // called when the write is fully committed and propagated. You can\n  // continue to add writes to the WriteFence up until it is triggered\n  // (calls its callbacks because all writes have committed.)\n  beginWrite: function beginWrite() {\n    var self = this;\n\n    if (self.retired) return { committed: function committed() {} };\n\n    if (self.fired) throw new Error(\"fence has already activated -- too late to add writes\");\n\n    self.outstanding_writes++;\n    var _committed = false;\n    return {\n      committed: function committed() {\n        if (_committed) throw new Error(\"committed called twice on the same write\");\n        _committed = true;\n        self.outstanding_writes--;\n        self._maybeFire();\n      }\n    };\n  },\n\n  // Arm the fence. Once the fence is armed, and there are no more\n  // uncommitted writes, it will activate.\n  arm: function arm() {\n    var self = this;\n    if (self === DDPServer._CurrentWriteFence.get()) throw Error(\"Can't arm the current fence\");\n    self.armed = true;\n    self._maybeFire();\n  },\n\n  // Register a function to be called once before firing the fence.\n  // Callback function can add new writes to the fence, in which case\n  // it won't fire until those writes are done as well.\n  onBeforeFire: function onBeforeFire(func) {\n    var self = this;\n    if (self.fired) throw new Error(\"fence has already activated -- too late to \" + \"add a callback\");\n    self.before_fire_callbacks.push(func);\n  },\n\n  // Register a function to be called when the fence fires.\n  onAllCommitted: function onAllCommitted(func) {\n    var self = this;\n    if (self.fired) throw new Error(\"fence has already activated -- too late to \" + \"add a callback\");\n    self.completion_callbacks.push(func);\n  },\n\n  // Convenience function. Arms the fence, then blocks until it fires.\n  armAndWait: function armAndWait() {\n    var self = this;\n    var future = new Future();\n    self.onAllCommitted(function () {\n      future['return']();\n    });\n    self.arm();\n    future.wait();\n  },\n\n  _maybeFire: function _maybeFire() {\n    var self = this;\n    if (self.fired) throw new Error(\"write fence already activated?\");\n    if (self.armed && !self.outstanding_writes) {\n      var invokeCallback = function invokeCallback(func) {\n        try {\n          func(self);\n        } catch (err) {\n          Meteor._debug(\"exception in write fence callback:\", err);\n        }\n      };\n\n      self.outstanding_writes++;\n      while (self.before_fire_callbacks.length > 0) {\n        var callbacks = self.before_fire_callbacks;\n        self.before_fire_callbacks = [];\n        _.each(callbacks, invokeCallback);\n      }\n      self.outstanding_writes--;\n\n      if (!self.outstanding_writes) {\n        self.fired = true;\n        var callbacks = self.completion_callbacks;\n        self.completion_callbacks = [];\n        _.each(callbacks, invokeCallback);\n      }\n    }\n  },\n\n  // Deactivate this fence so that adding more writes has no effect.\n  // The fence must have already fired.\n  retire: function retire() {\n    var self = this;\n    if (!self.fired) throw new Error(\"Can't retire a fence that hasn't fired.\");\n    self.retired = true;\n  }\n});","ast":null,"map":{"version":3,"sources":["/packages/ddp-server/writefence.js"],"names":[],"mappings":"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","file":"/packages/ddp-server/writefence.js.map","sourcesContent":["var path = Npm.require('path');\nvar Future = Npm.require(path.join('fibers', 'future'));\n\n// A write fence collects a group of writes, and provides a callback\n// when all of the writes are fully committed and propagated (all\n// observers have been notified of the write and acknowledged it.)\n//\nDDPServer._WriteFence = function () {\n  var self = this;\n\n  self.armed = false;\n  self.fired = false;\n  self.retired = false;\n  self.outstanding_writes = 0;\n  self.before_fire_callbacks = [];\n  self.completion_callbacks = [];\n};\n\n// The current write fence. When there is a current write fence, code\n// that writes to databases should register their writes with it using\n// beginWrite().\n//\nDDPServer._CurrentWriteFence = new Meteor.EnvironmentVariable;\n\n_.extend(DDPServer._WriteFence.prototype, {\n  // Start tracking a write, and return an object to represent it. The\n  // object has a single method, committed(). This method should be\n  // called when the write is fully committed and propagated. You can\n  // continue to add writes to the WriteFence up until it is triggered\n  // (calls its callbacks because all writes have committed.)\n  beginWrite: function () {\n    var self = this;\n\n    if (self.retired)\n      return { committed: function () {} };\n\n    if (self.fired)\n      throw new Error(\"fence has already activated -- too late to add writes\");\n\n    self.outstanding_writes++;\n    var committed = false;\n    return {\n      committed: function () {\n        if (committed)\n          throw new Error(\"committed called twice on the same write\");\n        committed = true;\n        self.outstanding_writes--;\n        self._maybeFire();\n      }\n    };\n  },\n\n  // Arm the fence. Once the fence is armed, and there are no more\n  // uncommitted writes, it will activate.\n  arm: function () {\n    var self = this;\n    if (self === DDPServer._CurrentWriteFence.get())\n      throw Error(\"Can't arm the current fence\");\n    self.armed = true;\n    self._maybeFire();\n  },\n\n  // Register a function to be called once before firing the fence.\n  // Callback function can add new writes to the fence, in which case\n  // it won't fire until those writes are done as well.\n  onBeforeFire: function (func) {\n    var self = this;\n    if (self.fired)\n      throw new Error(\"fence has already activated -- too late to \" +\n                      \"add a callback\");\n    self.before_fire_callbacks.push(func);\n  },\n\n  // Register a function to be called when the fence fires.\n  onAllCommitted: function (func) {\n    var self = this;\n    if (self.fired)\n      throw new Error(\"fence has already activated -- too late to \" +\n                      \"add a callback\");\n    self.completion_callbacks.push(func);\n  },\n\n  // Convenience function. Arms the fence, then blocks until it fires.\n  armAndWait: function () {\n    var self = this;\n    var future = new Future;\n    self.onAllCommitted(function () {\n      future['return']();\n    });\n    self.arm();\n    future.wait();\n  },\n\n  _maybeFire: function () {\n    var self = this;\n    if (self.fired)\n      throw new Error(\"write fence already activated?\");\n    if (self.armed && !self.outstanding_writes) {\n      function invokeCallback (func) {\n        try {\n          func(self);\n        } catch (err) {\n          Meteor._debug(\"exception in write fence callback:\", err);\n        }\n      }\n\n      self.outstanding_writes++;\n      while (self.before_fire_callbacks.length > 0) {\n        var callbacks = self.before_fire_callbacks;\n        self.before_fire_callbacks = [];\n        _.each(callbacks, invokeCallback);\n      }\n      self.outstanding_writes--;\n\n      if (!self.outstanding_writes) {\n        self.fired = true;\n        var callbacks = self.completion_callbacks;\n        self.completion_callbacks = [];\n        _.each(callbacks, invokeCallback);\n      }\n    }\n  },\n\n  // Deactivate this fence so that adding more writes has no effect.\n  // The fence must have already fired.\n  retire: function () {\n    var self = this;\n    if (! self.fired)\n      throw new Error(\"Can't retire a fence that hasn't fired.\");\n    self.retired = true;\n  }\n});\n"]},"hash":"33b2652b6b7a7de7d9f075c074aeccd038dd5eb3"}
