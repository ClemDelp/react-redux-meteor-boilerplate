{"metadata":{"usedHelpers":[],"marked":[],"modules":{"imports":[],"exports":{"exported":[],"specifiers":[]}}},"options":{"filename":"/packages/ddp-server/crossbar_tests.js","filenameRelative":"/packages/ddp-server/crossbar_tests.js","env":{},"retainLines":false,"highlightCode":true,"suppressDeprecationMessages":false,"presets":[],"plugins":[[[],{"polyfill":false}],[[],{"allowTopLevelThis":true,"strict":false,"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],{"loose":true}],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null]],"ignore":[],"code":true,"metadata":true,"ast":false,"comments":true,"compact":false,"minified":false,"sourceMap":true,"sourceMaps":true,"sourceMapTarget":"/packages/ddp-server/crossbar_tests.js.map","sourceFileName":"/packages/ddp-server/crossbar_tests.js","babelrc":false,"sourceType":"module","moduleIds":false,"passPerPreset":false,"basename":"crossbar_tests"},"ignored":false,"code":"// White box tests of invalidation crossbar matching function.\n// Note: the current crossbar match function is designed specifically\n// to ensure that a modification that targets a specific ID does not\n// notify a query that is watching a different specific ID. (And to\n// keep separate collections separate.) Other than that, there's no\n// deep meaning to the matching function, and it could be changed later\n// as long as it preserves that property.\nTinytest.add('livedata - crossbar', function (test) {\n  var crossbar = new DDPServer._Crossbar();\n  test.isTrue(crossbar._matches({ collection: \"C\" }, { collection: \"C\" }));\n  test.isTrue(crossbar._matches({ collection: \"C\", id: \"X\" }, { collection: \"C\" }));\n  test.isTrue(crossbar._matches({ collection: \"C\" }, { collection: \"C\", id: \"X\" }));\n  test.isTrue(crossbar._matches({ collection: \"C\", id: \"X\" }, { collection: \"C\" }));\n\n  test.isFalse(crossbar._matches({ collection: \"C\", id: \"X\" }, { collection: \"C\", id: \"Y\" }));\n\n  // Test that stopped listens definitely don't fire.\n  var calledFirst = false;\n  var calledSecond = false;\n  var trigger = { collection: \"C\" };\n  var secondHandle;\n  crossbar.listen(trigger, function (notification) {\n    // This test assumes that listeners will be called in the order\n    // registered. It's not wrong for the crossbar to do something different,\n    // but the test won't be valid in that case, so make it fail so we notice.\n    calledFirst = true;\n    if (calledSecond) {\n      test.fail({\n        type: \"test_assumption_failed\",\n        message: \"test assumed that listeners would be called in the order registered\"\n      });\n    } else {\n      secondHandle.stop();\n    }\n  });\n  secondHandle = crossbar.listen(trigger, function (notification) {\n    // This should not get invoked, because it should be stopped by the other\n    // listener!\n    calledSecond = true;\n  });\n  crossbar.fire(trigger);\n  test.isTrue(calledFirst);\n  test.isFalse(calledSecond);\n});","ast":null,"map":{"version":3,"sources":["/packages/ddp-server/crossbar_tests.js"],"names":[],"mappings":";;;;;;;AAOA,SAAS,GAAT,CAAa,qBAAb,EAAoC,UAAU,IAAV,EAAgB;AAClD,MAAI,WAAW,IAAI,UAAU,SAAd,EAAf;AACA,OAAK,MAAL,CAAY,SAAS,QAAT,CAAkB,EAAC,YAAY,GAAb,EAAlB,EACkB,EAAC,YAAY,GAAb,EADlB,CAAZ;AAEA,OAAK,MAAL,CAAY,SAAS,QAAT,CAAkB,EAAC,YAAY,GAAb,EAAkB,IAAI,GAAtB,EAAlB,EACkB,EAAC,YAAY,GAAb,EADlB,CAAZ;AAEA,OAAK,MAAL,CAAY,SAAS,QAAT,CAAkB,EAAC,YAAY,GAAb,EAAlB,EACkB,EAAC,YAAY,GAAb,EAAkB,IAAI,GAAtB,EADlB,CAAZ;AAEA,OAAK,MAAL,CAAY,SAAS,QAAT,CAAkB,EAAC,YAAY,GAAb,EAAkB,IAAI,GAAtB,EAAlB,EACkB,EAAC,YAAY,GAAb,EADlB,CAAZ;;AAGA,OAAK,OAAL,CAAa,SAAS,QAAT,CAAkB,EAAC,YAAY,GAAb,EAAkB,IAAI,GAAtB,EAAlB,EACkB,EAAC,YAAY,GAAb,EAAkB,IAAI,GAAtB,EADlB,CAAb;;;AAIA,MAAI,cAAc,KAAlB;AACA,MAAI,eAAe,KAAnB;AACA,MAAI,UAAU,EAAC,YAAY,GAAb,EAAd;AACA,MAAI,YAAJ;AACA,WAAS,MAAT,CAAgB,OAAhB,EAAyB,UAAU,YAAV,EAAwB;;;;AAI/C,kBAAc,IAAd;AACA,QAAI,YAAJ,EAAkB;AAChB,WAAK,IAAL,CAAU;AACR,cAAM,wBADE;AAER,iBAAS;AAFD,OAAV;AAID,KALD,MAKO;AACL,mBAAa,IAAb;AACD;AACF,GAbD;AAcA,iBAAe,SAAS,MAAT,CAAgB,OAAhB,EAAyB,UAAU,YAAV,EAAwB;;;AAG9D,mBAAe,IAAf;AACD,GAJc,CAAf;AAKA,WAAS,IAAT,CAAc,OAAd;AACA,OAAK,MAAL,CAAY,WAAZ;AACA,OAAK,OAAL,CAAa,YAAb;AACD,CAzCD","file":"/packages/ddp-server/crossbar_tests.js.map","sourcesContent":["// White box tests of invalidation crossbar matching function.\n// Note: the current crossbar match function is designed specifically\n// to ensure that a modification that targets a specific ID does not\n// notify a query that is watching a different specific ID. (And to\n// keep separate collections separate.) Other than that, there's no\n// deep meaning to the matching function, and it could be changed later\n// as long as it preserves that property.\nTinytest.add('livedata - crossbar', function (test) {\n  var crossbar = new DDPServer._Crossbar;\n  test.isTrue(crossbar._matches({collection: \"C\"},\n                                {collection: \"C\"}));\n  test.isTrue(crossbar._matches({collection: \"C\", id: \"X\"},\n                                {collection: \"C\"}));\n  test.isTrue(crossbar._matches({collection: \"C\"},\n                                {collection: \"C\", id: \"X\"}));\n  test.isTrue(crossbar._matches({collection: \"C\", id: \"X\"},\n                                {collection: \"C\"}));\n\n  test.isFalse(crossbar._matches({collection: \"C\", id: \"X\"},\n                                 {collection: \"C\", id: \"Y\"}));\n\n  // Test that stopped listens definitely don't fire.\n  var calledFirst = false;\n  var calledSecond = false;\n  var trigger = {collection: \"C\"};\n  var secondHandle;\n  crossbar.listen(trigger, function (notification) {\n    // This test assumes that listeners will be called in the order\n    // registered. It's not wrong for the crossbar to do something different,\n    // but the test won't be valid in that case, so make it fail so we notice.\n    calledFirst = true;\n    if (calledSecond) {\n      test.fail({\n        type: \"test_assumption_failed\",\n        message: \"test assumed that listeners would be called in the order registered\"\n      });\n    } else {\n      secondHandle.stop();\n    }\n  });\n  secondHandle = crossbar.listen(trigger, function (notification) {\n    // This should not get invoked, because it should be stopped by the other\n    // listener!\n    calledSecond = true;\n  });\n  crossbar.fire(trigger);\n  test.isTrue(calledFirst);\n  test.isFalse(calledSecond);\n});\n"]},"hash":"7b67bb8c9ad266a261ce358b887f56946eb06a9b"}
