{"metadata":{"usedHelpers":[],"marked":[],"modules":{"imports":[],"exports":{"exported":[],"specifiers":[]}}},"options":{"filename":"/packages/mongo/doc_fetcher.js","filenameRelative":"/packages/mongo/doc_fetcher.js","env":{},"retainLines":false,"highlightCode":true,"suppressDeprecationMessages":false,"presets":[],"plugins":[[[],{"polyfill":false}],[[],{"allowTopLevelThis":true,"strict":false,"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],{"loose":true}],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null]],"ignore":[],"code":true,"metadata":true,"ast":false,"comments":true,"compact":false,"minified":false,"sourceMap":true,"sourceMaps":true,"sourceMapTarget":"/packages/mongo/doc_fetcher.js.map","sourceFileName":"/packages/mongo/doc_fetcher.js","babelrc":false,"sourceType":"module","moduleIds":false,"passPerPreset":false,"basename":"doc_fetcher"},"ignored":false,"code":"var Fiber = Npm.require('fibers');\nvar Future = Npm.require('fibers/future');\n\nDocFetcher = function DocFetcher(mongoConnection) {\n  var self = this;\n  self._mongoConnection = mongoConnection;\n  // Map from cache key -> [callback]\n  self._callbacksForCacheKey = {};\n};\n\n_.extend(DocFetcher.prototype, {\n  // Fetches document \"id\" from collectionName, returning it or null if not\n  // found.\n  //\n  // If you make multiple calls to fetch() with the same cacheKey (a string),\n  // DocFetcher may assume that they all return the same document. (It does\n  // not check to see if collectionName/id match.)\n  //\n  // You may assume that callback is never called synchronously (and in fact\n  // OplogObserveDriver does so).\n  fetch: function fetch(collectionName, id, cacheKey, callback) {\n    var self = this;\n\n    check(collectionName, String);\n    // id is some sort of scalar\n    check(cacheKey, String);\n\n    // If there's already an in-progress fetch for this cache key, yield until\n    // it's done and return whatever it returns.\n    if (_.has(self._callbacksForCacheKey, cacheKey)) {\n      self._callbacksForCacheKey[cacheKey].push(callback);\n      return;\n    }\n\n    var callbacks = self._callbacksForCacheKey[cacheKey] = [callback];\n\n    Fiber(function () {\n      try {\n        var doc = self._mongoConnection.findOne(collectionName, { _id: id }) || null;\n        // Return doc to all relevant callbacks. Note that this array can\n        // continue to grow during callback excecution.\n        while (!_.isEmpty(callbacks)) {\n          // Clone the document so that the various calls to fetch don't return\n          // objects that are intertwingled with each other. Clone before\n          // popping the future, so that if clone throws, the error gets passed\n          // to the next callback.\n          var clonedDoc = EJSON.clone(doc);\n          callbacks.pop()(null, clonedDoc);\n        }\n      } catch (e) {\n        while (!_.isEmpty(callbacks)) {\n          callbacks.pop()(e);\n        }\n      } finally {\n        // XXX consider keeping the doc around for a period of time before\n        // removing from the cache\n        delete self._callbacksForCacheKey[cacheKey];\n      }\n    }).run();\n  }\n});\n\nMongoTest.DocFetcher = DocFetcher;","ast":null,"map":{"version":3,"sources":["/packages/mongo/doc_fetcher.js"],"names":[],"mappings":"AAAA,IAAI,QAAQ,IAAI,OAAJ,CAAY,QAAZ,CAAZ;AACA,IAAI,SAAS,IAAI,OAAJ,CAAY,eAAZ,CAAb;;AAEA,aAAa,oBAAU,eAAV,EAA2B;AACtC,MAAI,OAAO,IAAX;AACA,OAAK,gBAAL,GAAwB,eAAxB;;AAEA,OAAK,qBAAL,GAA6B,EAA7B;AACD,CALD;;AAOA,EAAE,MAAF,CAAS,WAAW,SAApB,EAA+B;;;;;;;;;;AAU7B,SAAO,eAAU,cAAV,EAA0B,EAA1B,EAA8B,QAA9B,EAAwC,QAAxC,EAAkD;AACvD,QAAI,OAAO,IAAX;;AAEA,UAAM,cAAN,EAAsB,MAAtB;;AAEA,UAAM,QAAN,EAAgB,MAAhB;;;;AAIA,QAAI,EAAE,GAAF,CAAM,KAAK,qBAAX,EAAkC,QAAlC,CAAJ,EAAiD;AAC/C,WAAK,qBAAL,CAA2B,QAA3B,EAAqC,IAArC,CAA0C,QAA1C;AACA;AACD;;AAED,QAAI,YAAY,KAAK,qBAAL,CAA2B,QAA3B,IAAuC,CAAC,QAAD,CAAvD;;AAEA,UAAM,YAAY;AAChB,UAAI;AACF,YAAI,MAAM,KAAK,gBAAL,CAAsB,OAAtB,CACR,cADQ,EACQ,EAAC,KAAK,EAAN,EADR,KACsB,IADhC;;;AAIA,eAAO,CAAC,EAAE,OAAF,CAAU,SAAV,CAAR,EAA8B;;;;;AAK5B,cAAI,YAAY,MAAM,KAAN,CAAY,GAAZ,CAAhB;AACA,oBAAU,GAAV,GAAgB,IAAhB,EAAsB,SAAtB;AACD;AACF,OAbD,CAaE,OAAO,CAAP,EAAU;AACV,eAAO,CAAC,EAAE,OAAF,CAAU,SAAV,CAAR,EAA8B;AAC5B,oBAAU,GAAV,GAAgB,CAAhB;AACD;AACF,OAjBD,SAiBU;;;AAGR,eAAO,KAAK,qBAAL,CAA2B,QAA3B,CAAP;AACD;AACF,KAvBD,EAuBG,GAvBH;AAwBD;AAlD4B,CAA/B;;AAqDA,UAAU,UAAV,GAAuB,UAAvB","file":"/packages/mongo/doc_fetcher.js.map","sourcesContent":["var Fiber = Npm.require('fibers');\nvar Future = Npm.require('fibers/future');\n\nDocFetcher = function (mongoConnection) {\n  var self = this;\n  self._mongoConnection = mongoConnection;\n  // Map from cache key -> [callback]\n  self._callbacksForCacheKey = {};\n};\n\n_.extend(DocFetcher.prototype, {\n  // Fetches document \"id\" from collectionName, returning it or null if not\n  // found.\n  //\n  // If you make multiple calls to fetch() with the same cacheKey (a string),\n  // DocFetcher may assume that they all return the same document. (It does\n  // not check to see if collectionName/id match.)\n  //\n  // You may assume that callback is never called synchronously (and in fact\n  // OplogObserveDriver does so).\n  fetch: function (collectionName, id, cacheKey, callback) {\n    var self = this;\n\n    check(collectionName, String);\n    // id is some sort of scalar\n    check(cacheKey, String);\n\n    // If there's already an in-progress fetch for this cache key, yield until\n    // it's done and return whatever it returns.\n    if (_.has(self._callbacksForCacheKey, cacheKey)) {\n      self._callbacksForCacheKey[cacheKey].push(callback);\n      return;\n    }\n\n    var callbacks = self._callbacksForCacheKey[cacheKey] = [callback];\n\n    Fiber(function () {\n      try {\n        var doc = self._mongoConnection.findOne(\n          collectionName, {_id: id}) || null;\n        // Return doc to all relevant callbacks. Note that this array can\n        // continue to grow during callback excecution.\n        while (!_.isEmpty(callbacks)) {\n          // Clone the document so that the various calls to fetch don't return\n          // objects that are intertwingled with each other. Clone before\n          // popping the future, so that if clone throws, the error gets passed\n          // to the next callback.\n          var clonedDoc = EJSON.clone(doc);\n          callbacks.pop()(null, clonedDoc);\n        }\n      } catch (e) {\n        while (!_.isEmpty(callbacks)) {\n          callbacks.pop()(e);\n        }\n      } finally {\n        // XXX consider keeping the doc around for a period of time before\n        // removing from the cache\n        delete self._callbacksForCacheKey[cacheKey];\n      }\n    }).run();\n  }\n});\n\nMongoTest.DocFetcher = DocFetcher;\n"]},"hash":"eeaf5c5921abb3f1aa5d5a9b0f2b9f91d1179a8f"}
