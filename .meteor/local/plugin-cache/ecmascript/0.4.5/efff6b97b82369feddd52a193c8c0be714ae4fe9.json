{"metadata":{"usedHelpers":[],"marked":[],"modules":{"imports":[],"exports":{"exported":[],"specifiers":[]}}},"options":{"filename":"/packages/mongo/allow_tests.js","filenameRelative":"/packages/mongo/allow_tests.js","env":{},"retainLines":false,"highlightCode":true,"suppressDeprecationMessages":false,"presets":[],"plugins":[[[],{"polyfill":false}],[[],{"allowTopLevelThis":true,"strict":false,"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],{"loose":true}],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null]],"ignore":[],"code":true,"metadata":true,"ast":false,"comments":true,"compact":false,"minified":false,"sourceMap":true,"sourceMaps":true,"sourceMapTarget":"/packages/mongo/allow_tests.js.map","sourceFileName":"/packages/mongo/allow_tests.js","babelrc":false,"sourceType":"module","moduleIds":false,"passPerPreset":false,"basename":"allow_tests"},"ignored":false,"code":"if (Meteor.isServer) {\n  // Set up allow/deny rules for test collections\n\n  var allowCollections = {};\n\n  // We create the collections in the publisher (instead of using a method or\n  // something) because if we made them with a method, we'd need to follow the\n  // method with some subscribes, and it's possible that the method call would\n  // be delayed by a wait method and the subscribe messages would be sent before\n  // it and fail due to the collection not yet existing. So we are very hacky\n  // and use a publish.\n  Meteor.publish(\"allowTests\", function (nonce, idGeneration) {\n    check(nonce, String);\n    check(idGeneration, String);\n    var cursors = [];\n    var needToConfigure = undefined;\n\n    // helper for defining a collection. we are careful to create just one\n    // Mongo.Collection even if the sub body is rerun, by caching them.\n    var defineCollection = function defineCollection(name, insecure, transform) {\n      var fullName = name + idGeneration + nonce;\n\n      var collection;\n      if (_.has(allowCollections, fullName)) {\n        collection = allowCollections[fullName];\n        if (needToConfigure === true) throw new Error(\"collections inconsistently exist\");\n        needToConfigure = false;\n      } else {\n        collection = new Mongo.Collection(fullName, { idGeneration: idGeneration, transform: transform });\n        allowCollections[fullName] = collection;\n        if (needToConfigure === false) throw new Error(\"collections inconsistently don't exist\");\n        needToConfigure = true;\n        collection._insecure = insecure;\n        var m = {};\n        m[\"clear-collection-\" + fullName] = function () {\n          collection.remove({});\n        };\n        Meteor.methods(m);\n      }\n\n      cursors.push(collection.find());\n      return collection;\n    };\n\n    var insecureCollection = defineCollection(\"collection-insecure\", true /*insecure*/);\n    // totally locked down collection\n    var lockedDownCollection = defineCollection(\"collection-locked-down\", false /*insecure*/);\n    // restricted collection with same allowed modifications, both with and\n    // without the `insecure` package\n    var restrictedCollectionDefaultSecure = defineCollection(\"collection-restrictedDefaultSecure\", false /*insecure*/);\n    var restrictedCollectionDefaultInsecure = defineCollection(\"collection-restrictedDefaultInsecure\", true /*insecure*/);\n    var restrictedCollectionForUpdateOptionsTest = defineCollection(\"collection-restrictedForUpdateOptionsTest\", true /*insecure*/);\n    var restrictedCollectionForPartialAllowTest = defineCollection(\"collection-restrictedForPartialAllowTest\", true /*insecure*/);\n    var restrictedCollectionForPartialDenyTest = defineCollection(\"collection-restrictedForPartialDenyTest\", true /*insecure*/);\n    var restrictedCollectionForFetchTest = defineCollection(\"collection-restrictedForFetchTest\", true /*insecure*/);\n    var restrictedCollectionForFetchAllTest = defineCollection(\"collection-restrictedForFetchAllTest\", true /*insecure*/);\n    var restrictedCollectionWithTransform = defineCollection(\"withTransform\", false, function (doc) {\n      return doc.a;\n    });\n    var restrictedCollectionForInvalidTransformTest = defineCollection(\"collection-restrictedForInvalidTransform\", false /*insecure*/);\n    var restrictedCollectionForClientIdTest = defineCollection(\"collection-restrictedForClientIdTest\", false /*insecure*/);\n\n    if (needToConfigure) {\n      restrictedCollectionWithTransform.allow({\n        insert: function insert(userId, doc) {\n          return doc.foo === \"foo\";\n        },\n        update: function update(userId, doc) {\n          return doc.foo === \"foo\";\n        },\n        remove: function remove(userId, doc) {\n          return doc.bar === \"bar\";\n        }\n      });\n      restrictedCollectionWithTransform.allow({\n        // transform: null means that doc here is the top level, not the 'a'\n        // element.\n        transform: null,\n        insert: function insert(userId, doc) {\n          return !!doc.topLevelField;\n        },\n        update: function update(userId, doc) {\n          return !!doc.topLevelField;\n        }\n      });\n      restrictedCollectionForInvalidTransformTest.allow({\n        // transform must return an object which is not a mongo id\n        transform: function transform(doc) {\n          return doc._id;\n        },\n        insert: function insert() {\n          return true;\n        }\n      });\n      restrictedCollectionForClientIdTest.allow({\n        // This test just requires the collection to trigger the restricted\n        // case.\n        insert: function insert() {\n          return true;\n        }\n      });\n\n      // two calls to allow to verify that either validator is sufficient.\n      var allows = [{\n        insert: function insert(userId, doc) {\n          return doc.canInsert;\n        },\n        update: function update(userId, doc) {\n          return doc.canUpdate;\n        },\n        remove: function remove(userId, doc) {\n          return doc.canRemove;\n        }\n      }, {\n        insert: function insert(userId, doc) {\n          return doc.canInsert2;\n        },\n        update: function update(userId, doc, fields, modifier) {\n          return -1 !== _.indexOf(fields, 'canUpdate2');\n        },\n        remove: function remove(userId, doc) {\n          return doc.canRemove2;\n        }\n      }];\n\n      // two calls to deny to verify that either one blocks the change.\n      var denies = [{\n        insert: function insert(userId, doc) {\n          return doc.cantInsert;\n        },\n        remove: function remove(userId, doc) {\n          return doc.cantRemove;\n        }\n      }, {\n        insert: function insert(userId, doc) {\n          // Don't allow explicit ID to be set by the client.\n          return _.has(doc, '_id');\n        },\n        update: function update(userId, doc, fields, modifier) {\n          return -1 !== _.indexOf(fields, 'verySecret');\n        }\n      }];\n\n      _.each([restrictedCollectionDefaultSecure, restrictedCollectionDefaultInsecure, restrictedCollectionForUpdateOptionsTest], function (collection) {\n        _.each(allows, function (allow) {\n          collection.allow(allow);\n        });\n        _.each(denies, function (deny) {\n          collection.deny(deny);\n        });\n      });\n\n      // just restrict one operation so that we can verify that others\n      // fail\n      restrictedCollectionForPartialAllowTest.allow({\n        insert: function insert() {}\n      });\n      restrictedCollectionForPartialDenyTest.deny({\n        insert: function insert() {}\n      });\n\n      // verify that we only fetch the fields specified - we should\n      // be fetching just field1, field2, and field3.\n      restrictedCollectionForFetchTest.allow({\n        insert: function insert() {\n          return true;\n        },\n        update: function update(userId, doc) {\n          // throw fields in doc so that we can inspect them in test\n          throw new Meteor.Error(999, \"Test: Fields in doc: \" + _.keys(doc).sort().join(','));\n        },\n        remove: function remove(userId, doc) {\n          // throw fields in doc so that we can inspect them in test\n          throw new Meteor.Error(999, \"Test: Fields in doc: \" + _.keys(doc).sort().join(','));\n        },\n        fetch: ['field1']\n      });\n      restrictedCollectionForFetchTest.allow({\n        fetch: ['field2']\n      });\n      restrictedCollectionForFetchTest.deny({\n        fetch: ['field3']\n      });\n\n      // verify that not passing fetch to one of the calls to allow\n      // causes all fields to be fetched\n      restrictedCollectionForFetchAllTest.allow({\n        insert: function insert() {\n          return true;\n        },\n        update: function update(userId, doc) {\n          // throw fields in doc so that we can inspect them in test\n          throw new Meteor.Error(999, \"Test: Fields in doc: \" + _.keys(doc).sort().join(','));\n        },\n        remove: function remove(userId, doc) {\n          // throw fields in doc so that we can inspect them in test\n          throw new Meteor.Error(999, \"Test: Fields in doc: \" + _.keys(doc).sort().join(','));\n        },\n        fetch: ['field1']\n      });\n      restrictedCollectionForFetchAllTest.allow({\n        update: function update() {\n          return true;\n        }\n      });\n    }\n\n    return cursors;\n  });\n}\n\nif (Meteor.isClient) {\n  _.each(['STRING', 'MONGO'], function (idGeneration) {\n    // Set up a bunch of test collections... on the client! They match the ones\n    // created by setUpAllowTestsCollections.\n\n    var nonce = Random.id();\n    // Tell the server to make, configure, and publish a set of collections unique\n    // to our test run. Since the method does not unblock, this will complete\n    // running on the server before anything else happens.\n    Meteor.subscribe('allowTests', nonce, idGeneration);\n\n    // helper for defining a collection, subscribing to it, and defining\n    // a method to clear it\n    var defineCollection = function defineCollection(name, transform) {\n      var fullName = name + idGeneration + nonce;\n      var collection = new Mongo.Collection(fullName, { idGeneration: idGeneration, transform: transform });\n\n      collection.callClearMethod = function (callback) {\n        Meteor.call(\"clear-collection-\" + fullName, callback);\n      };\n      collection.unnoncedName = name + idGeneration;\n      return collection;\n    };\n\n    // totally insecure collection\n    var insecureCollection = defineCollection(\"collection-insecure\");\n\n    // totally locked down collection\n    var lockedDownCollection = defineCollection(\"collection-locked-down\");\n\n    // restricted collection with same allowed modifications, both with and\n    // without the `insecure` package\n    var restrictedCollectionDefaultSecure = defineCollection(\"collection-restrictedDefaultSecure\");\n    var restrictedCollectionDefaultInsecure = defineCollection(\"collection-restrictedDefaultInsecure\");\n    var restrictedCollectionForUpdateOptionsTest = defineCollection(\"collection-restrictedForUpdateOptionsTest\");\n    var restrictedCollectionForPartialAllowTest = defineCollection(\"collection-restrictedForPartialAllowTest\");\n    var restrictedCollectionForPartialDenyTest = defineCollection(\"collection-restrictedForPartialDenyTest\");\n    var restrictedCollectionForFetchTest = defineCollection(\"collection-restrictedForFetchTest\");\n    var restrictedCollectionForFetchAllTest = defineCollection(\"collection-restrictedForFetchAllTest\");\n    var restrictedCollectionWithTransform = defineCollection(\"withTransform\", function (doc) {\n      return doc.a;\n    });\n    var restrictedCollectionForInvalidTransformTest = defineCollection(\"collection-restrictedForInvalidTransform\");\n    var restrictedCollectionForClientIdTest = defineCollection(\"collection-restrictedForClientIdTest\");\n\n    // test that if allow is called once then the collection is\n    // restricted, and that other mutations aren't allowed\n    testAsyncMulti(\"collection - partial allow, \" + idGeneration, [function (test, expect) {\n      restrictedCollectionForPartialAllowTest.update('foo', { $set: { updated: true } }, expect(function (err, res) {\n        test.equal(err.error, 403);\n      }));\n    }]);\n\n    // test that if deny is called once then the collection is\n    // restricted, and that other mutations aren't allowed\n    testAsyncMulti(\"collection - partial deny, \" + idGeneration, [function (test, expect) {\n      restrictedCollectionForPartialDenyTest.update('foo', { $set: { updated: true } }, expect(function (err, res) {\n        test.equal(err.error, 403);\n      }));\n    }]);\n\n    // test that we only fetch the fields specified\n    testAsyncMulti(\"collection - fetch, \" + idGeneration, [function (test, expect) {\n      var fetchId = restrictedCollectionForFetchTest.insert({ field1: 1, field2: 1, field3: 1, field4: 1 });\n      var fetchAllId = restrictedCollectionForFetchAllTest.insert({ field1: 1, field2: 1, field3: 1, field4: 1 });\n      restrictedCollectionForFetchTest.update(fetchId, { $set: { updated: true } }, expect(function (err, res) {\n        test.equal(err.reason, \"Test: Fields in doc: _id,field1,field2,field3\");\n      }));\n      restrictedCollectionForFetchTest.remove(fetchId, expect(function (err, res) {\n        test.equal(err.reason, \"Test: Fields in doc: _id,field1,field2,field3\");\n      }));\n\n      restrictedCollectionForFetchAllTest.update(fetchAllId, { $set: { updated: true } }, expect(function (err, res) {\n        test.equal(err.reason, \"Test: Fields in doc: _id,field1,field2,field3,field4\");\n      }));\n      restrictedCollectionForFetchAllTest.remove(fetchAllId, expect(function (err, res) {\n        test.equal(err.reason, \"Test: Fields in doc: _id,field1,field2,field3,field4\");\n      }));\n    }]);\n\n    (function () {\n      testAsyncMulti(\"collection - restricted factories \" + idGeneration, [function (test, expect) {\n        restrictedCollectionWithTransform.callClearMethod(expect(function () {\n          test.equal(restrictedCollectionWithTransform.find().count(), 0);\n        }));\n      }, function (test, expect) {\n        var self = this;\n        restrictedCollectionWithTransform.insert({\n          a: { foo: \"foo\", bar: \"bar\", baz: \"baz\" }\n        }, expect(function (e, res) {\n          test.isFalse(e);\n          test.isTrue(res);\n          self.item1 = res;\n        }));\n        restrictedCollectionWithTransform.insert({\n          a: { foo: \"foo\", bar: \"quux\", baz: \"quux\" },\n          b: \"potato\"\n        }, expect(function (e, res) {\n          test.isFalse(e);\n          test.isTrue(res);\n          self.item2 = res;\n        }));\n        restrictedCollectionWithTransform.insert({\n          a: { foo: \"adsfadf\", bar: \"quux\", baz: \"quux\" },\n          b: \"potato\"\n        }, expect(function (e, res) {\n          test.isTrue(e);\n        }));\n        restrictedCollectionWithTransform.insert({\n          a: { foo: \"bar\" },\n          topLevelField: true\n        }, expect(function (e, res) {\n          test.isFalse(e);\n          test.isTrue(res);\n          self.item3 = res;\n        }));\n      }, function (test, expect) {\n        var self = this;\n        // This should work, because there is an update allow for things with\n        // topLevelField.\n        restrictedCollectionWithTransform.update(self.item3, { $set: { xxx: true } }, expect(function (e, res) {\n          test.isFalse(e);\n          test.equal(1, res);\n        }));\n      }, function (test, expect) {\n        var self = this;\n        test.equal(restrictedCollectionWithTransform.findOne(self.item1), { _id: self.item1, foo: \"foo\", bar: \"bar\", baz: \"baz\" });\n        restrictedCollectionWithTransform.remove(self.item1, expect(function (e, res) {\n          test.isFalse(e);\n        }));\n        restrictedCollectionWithTransform.remove(self.item2, expect(function (e, res) {\n          test.isTrue(e);\n        }));\n      }]);\n    })();\n\n    testAsyncMulti(\"collection - insecure, \" + idGeneration, [function (test, expect) {\n      insecureCollection.callClearMethod(expect(function () {\n        test.equal(insecureCollection.find().count(), 0);\n      }));\n    }, function (test, expect) {\n      var id = insecureCollection.insert({ foo: 'bar' }, expect(function (err, res) {\n        test.equal(res, id);\n        test.equal(insecureCollection.find(id).count(), 1);\n        test.equal(insecureCollection.findOne(id).foo, 'bar');\n      }));\n      test.equal(insecureCollection.find(id).count(), 1);\n      test.equal(insecureCollection.findOne(id).foo, 'bar');\n    }]);\n\n    testAsyncMulti(\"collection - locked down, \" + idGeneration, [function (test, expect) {\n      lockedDownCollection.callClearMethod(expect(function () {\n        test.equal(lockedDownCollection.find().count(), 0);\n      }));\n    }, function (test, expect) {\n      lockedDownCollection.insert({ foo: 'bar' }, expect(function (err, res) {\n        test.equal(err.error, 403);\n        test.equal(lockedDownCollection.find().count(), 0);\n      }));\n    }]);\n\n    (function () {\n      var collection = restrictedCollectionForUpdateOptionsTest;\n      var id1, id2;\n      testAsyncMulti(\"collection - update options, \" + idGeneration, [\n      // init\n      function (test, expect) {\n        collection.callClearMethod(expect(function () {\n          test.equal(collection.find().count(), 0);\n        }));\n      },\n      // put a few objects\n      function (test, expect) {\n        var doc = { canInsert: true, canUpdate: true };\n        id1 = collection.insert(doc);\n        id2 = collection.insert(doc);\n        collection.insert(doc);\n        collection.insert(doc, expect(function (err, res) {\n          test.isFalse(err);\n          test.equal(collection.find().count(), 4);\n        }));\n      },\n      // update by id\n      function (test, expect) {\n        collection.update(id1, { $set: { updated: true } }, expect(function (err, res) {\n          test.isFalse(err);\n          test.equal(res, 1);\n          test.equal(collection.find({ updated: true }).count(), 1);\n        }));\n      },\n      // update by id in an object\n      function (test, expect) {\n        collection.update({ _id: id2 }, { $set: { updated: true } }, expect(function (err, res) {\n          test.isFalse(err);\n          test.equal(res, 1);\n          test.equal(collection.find({ updated: true }).count(), 2);\n        }));\n      },\n      // update with replacement operator not allowed, and has nice error.\n      function (test, expect) {\n        collection.update({ _id: id2 }, { _id: id2, updated: true }, expect(function (err, res) {\n          test.equal(err.error, 403);\n          test.matches(err.reason, /In a restricted/);\n          // unchanged\n          test.equal(collection.find({ updated: true }).count(), 2);\n        }));\n      },\n      // upsert not allowed, and has nice error.\n      function (test, expect) {\n        collection.update({ _id: id2 }, { $set: { upserted: true } }, { upsert: true }, expect(function (err, res) {\n          test.equal(err.error, 403);\n          test.matches(err.reason, /in a restricted/);\n          test.equal(collection.find({ upserted: true }).count(), 0);\n        }));\n      },\n      // update with rename operator not allowed, and has nice error.\n      function (test, expect) {\n        collection.update({ _id: id2 }, { $rename: { updated: 'asdf' } }, expect(function (err, res) {\n          test.equal(err.error, 403);\n          test.matches(err.reason, /not allowed/);\n          // unchanged\n          test.equal(collection.find({ updated: true }).count(), 2);\n        }));\n      },\n      // update method with a non-ID selector is not allowed\n      function (test, expect) {\n        // We shouldn't even send the method...\n        test.throws(function () {\n          collection.update({ updated: { $exists: false } }, { $set: { updated: true } });\n        });\n        // ... but if we did, the server would reject it too.\n        Meteor.call('/' + collection._name + '/update', { updated: { $exists: false } }, { $set: { updated: true } }, expect(function (err, res) {\n          test.equal(err.error, 403);\n          // unchanged\n          test.equal(collection.find({ updated: true }).count(), 2);\n        }));\n      },\n      // make sure it doesn't think that {_id: 'foo', something: else} is ok.\n      function (test, expect) {\n        test.throws(function () {\n          collection.update({ _id: id1, updated: { $exists: false } }, { $set: { updated: true } });\n        });\n      },\n      // remove method with a non-ID selector is not allowed\n      function (test, expect) {\n        // We shouldn't even send the method...\n        test.throws(function () {\n          collection.remove({ updated: true });\n        });\n        // ... but if we did, the server would reject it too.\n        Meteor.call('/' + collection._name + '/remove', { updated: true }, expect(function (err, res) {\n          test.equal(err.error, 403);\n          // unchanged\n          test.equal(collection.find({ updated: true }).count(), 2);\n        }));\n      }]);\n    })();\n\n    _.each([restrictedCollectionDefaultInsecure, restrictedCollectionDefaultSecure], function (collection) {\n      var canUpdateId, canRemoveId;\n\n      testAsyncMulti(\"collection - \" + collection.unnoncedName, [\n      // init\n      function (test, expect) {\n        collection.callClearMethod(expect(function () {\n          test.equal(collection.find().count(), 0);\n        }));\n      },\n\n      // insert with no allows passing. request is denied.\n      function (test, expect) {\n        collection.insert({}, expect(function (err, res) {\n          test.equal(err.error, 403);\n          test.equal(collection.find().count(), 0);\n        }));\n      },\n      // insert with one allow and one deny. denied.\n      function (test, expect) {\n        collection.insert({ canInsert: true, cantInsert: true }, expect(function (err, res) {\n          test.equal(err.error, 403);\n          test.equal(collection.find().count(), 0);\n        }));\n      },\n      // insert with one allow and other deny. denied.\n      function (test, expect) {\n        collection.insert({ canInsert: true, _id: Random.id() }, expect(function (err, res) {\n          test.equal(err.error, 403);\n          test.equal(collection.find().count(), 0);\n        }));\n      },\n      // insert one allow passes. allowed.\n      function (test, expect) {\n        collection.insert({ canInsert: true }, expect(function (err, res) {\n          test.isFalse(err);\n          test.equal(collection.find().count(), 1);\n        }));\n      },\n      // insert other allow passes. allowed.\n      // includes canUpdate for later.\n      function (test, expect) {\n        canUpdateId = collection.insert({ canInsert2: true, canUpdate: true }, expect(function (err, res) {\n          test.isFalse(err);\n          test.equal(collection.find().count(), 2);\n        }));\n      },\n      // yet a third insert executes. this one has canRemove and\n      // cantRemove set for later.\n      function (test, expect) {\n        canRemoveId = collection.insert({ canInsert: true, canRemove: true, cantRemove: true }, expect(function (err, res) {\n          test.isFalse(err);\n          test.equal(collection.find().count(), 3);\n        }));\n      },\n\n      // can't update with a non-operator mutation\n      function (test, expect) {\n        collection.update(canUpdateId, { newObject: 1 }, expect(function (err, res) {\n          test.equal(err.error, 403);\n          test.equal(collection.find().count(), 3);\n        }));\n      },\n\n      // updating dotted fields works as if we are changing their\n      // top part\n      function (test, expect) {\n        collection.update(canUpdateId, { $set: { \"dotted.field\": 1 } }, expect(function (err, res) {\n          test.isFalse(err);\n          test.equal(res, 1);\n          test.equal(collection.findOne(canUpdateId).dotted.field, 1);\n        }));\n      }, function (test, expect) {\n        collection.update(canUpdateId, { $set: { \"verySecret.field\": 1 } }, expect(function (err, res) {\n          test.equal(err.error, 403);\n          test.equal(collection.find({ verySecret: { $exists: true } }).count(), 0);\n        }));\n      },\n\n      // update doesn't do anything if no docs match\n      function (test, expect) {\n        collection.update(\"doesn't exist\", { $set: { updated: true } }, expect(function (err, res) {\n          test.isFalse(err);\n          test.equal(res, 0);\n          // nothing has changed\n          test.equal(collection.find().count(), 3);\n          test.equal(collection.find({ updated: true }).count(), 0);\n        }));\n      },\n      // update fails when access is denied trying to set `verySecret`\n      function (test, expect) {\n        collection.update(canUpdateId, { $set: { verySecret: true } }, expect(function (err, res) {\n          test.equal(err.error, 403);\n          // nothing has changed\n          test.equal(collection.find().count(), 3);\n          test.equal(collection.find({ updated: true }).count(), 0);\n        }));\n      },\n      // update fails when trying to set two fields, one of which is\n      // `verySecret`\n      function (test, expect) {\n        collection.update(canUpdateId, { $set: { updated: true, verySecret: true } }, expect(function (err, res) {\n          test.equal(err.error, 403);\n          // nothing has changed\n          test.equal(collection.find().count(), 3);\n          test.equal(collection.find({ updated: true }).count(), 0);\n        }));\n      },\n      // update fails when trying to modify docs that don't\n      // have `canUpdate` set\n      function (test, expect) {\n        collection.update(canRemoveId, { $set: { updated: true } }, expect(function (err, res) {\n          test.equal(err.error, 403);\n          // nothing has changed\n          test.equal(collection.find().count(), 3);\n          test.equal(collection.find({ updated: true }).count(), 0);\n        }));\n      },\n      // update executes when it should\n      function (test, expect) {\n        collection.update(canUpdateId, { $set: { updated: true } }, expect(function (err, res) {\n          test.isFalse(err);\n          test.equal(res, 1);\n          test.equal(collection.find({ updated: true }).count(), 1);\n        }));\n      },\n\n      // remove fails when trying to modify a doc with no `canRemove` set\n      function (test, expect) {\n        collection.remove(canUpdateId, expect(function (err, res) {\n          test.equal(err.error, 403);\n          // nothing has changed\n          test.equal(collection.find().count(), 3);\n        }));\n      },\n      // remove fails when trying to modify an doc with `cantRemove`\n      // set\n      function (test, expect) {\n        collection.remove(canRemoveId, expect(function (err, res) {\n          test.equal(err.error, 403);\n          // nothing has changed\n          test.equal(collection.find().count(), 3);\n        }));\n      },\n\n      // update the doc to remove cantRemove.\n      function (test, expect) {\n        collection.update(canRemoveId, { $set: { cantRemove: false, canUpdate2: true } }, expect(function (err, res) {\n          test.isFalse(err);\n          test.equal(res, 1);\n          test.equal(collection.find({ cantRemove: true }).count(), 0);\n        }));\n      },\n\n      // now remove can remove it.\n      function (test, expect) {\n        collection.remove(canRemoveId, expect(function (err, res) {\n          test.isFalse(err);\n          test.equal(res, 1);\n          // successfully removed\n          test.equal(collection.find().count(), 2);\n        }));\n      },\n\n      // try to remove a doc that doesn't exist. see we remove no docs.\n      function (test, expect) {\n        collection.remove('some-random-id-that-never-matches', expect(function (err, res) {\n          test.isFalse(err);\n          test.equal(res, 0);\n          // nothing removed\n          test.equal(collection.find().count(), 2);\n        }));\n      },\n\n      // methods can still bypass restrictions\n      function (test, expect) {\n        collection.callClearMethod(expect(function (err, res) {\n          test.isFalse(err);\n          // successfully removed\n          test.equal(collection.find().count(), 0);\n        }));\n      }]);\n    });\n    testAsyncMulti(\"collection - allow/deny transform must return object, \" + idGeneration, [function (test, expect) {\n      restrictedCollectionForInvalidTransformTest.insert({}, expect(function (err, res) {\n        test.isTrue(err);\n      }));\n    }]);\n    testAsyncMulti(\"collection - restricted collection allows client-side id, \" + idGeneration, [function (test, expect) {\n      var self = this;\n      self.id = Random.id();\n      restrictedCollectionForClientIdTest.insert({ _id: self.id }, expect(function (err, res) {\n        test.isFalse(err);\n        test.equal(res, self.id);\n        test.equal(restrictedCollectionForClientIdTest.findOne(self.id), { _id: self.id });\n      }));\n    }]);\n  }); // end idGeneration loop\n} // end if isClient\n\n// A few simple server-only tests which don't need to coordinate collections\n// with the client..\nif (Meteor.isServer) {\n  Tinytest.add(\"collection - allow and deny validate options\", function (test) {\n    var collection = new Mongo.Collection(null);\n\n    test.throws(function () {\n      collection.allow({ invalidOption: true });\n    });\n    test.throws(function () {\n      collection.deny({ invalidOption: true });\n    });\n\n    _.each(['insert', 'update', 'remove', 'fetch'], function (key) {\n      var options = {};\n      options[key] = true;\n      test.throws(function () {\n        collection.allow(options);\n      });\n      test.throws(function () {\n        collection.deny(options);\n      });\n    });\n\n    _.each(['insert', 'update', 'remove'], function (key) {\n      var options = {};\n      options[key] = false;\n      test.throws(function () {\n        collection.allow(options);\n      });\n      test.throws(function () {\n        collection.deny(options);\n      });\n    });\n\n    _.each(['insert', 'update', 'remove'], function (key) {\n      var options = {};\n      options[key] = undefined;\n      test.throws(function () {\n        collection.allow(options);\n      });\n      test.throws(function () {\n        collection.deny(options);\n      });\n    });\n\n    _.each(['insert', 'update', 'remove'], function (key) {\n      var options = {};\n      options[key] = ['an array']; // this should be a function, not an array\n      test.throws(function () {\n        collection.allow(options);\n      });\n      test.throws(function () {\n        collection.deny(options);\n      });\n    });\n\n    test.throws(function () {\n      collection.allow({ fetch: function fetch() {} }); // this should be an array\n    });\n  });\n\n  Tinytest.add(\"collection - calling allow restricts\", function (test) {\n    var collection = new Mongo.Collection(null);\n    test.equal(collection._restricted, false);\n    collection.allow({\n      insert: function insert() {}\n    });\n    test.equal(collection._restricted, true);\n  });\n\n  Tinytest.add(\"collection - global insecure\", function (test) {\n    // note: This test alters the global insecure status, by sneakily hacking\n    // the global Package object!\n    var insecurePackage = Package.insecure;\n\n    Package.insecure = {};\n    var collection = new Mongo.Collection(null);\n    test.equal(collection._isInsecure(), true);\n\n    Package.insecure = undefined;\n    test.equal(collection._isInsecure(), false);\n\n    delete Package.insecure;\n    test.equal(collection._isInsecure(), false);\n\n    collection._insecure = true;\n    test.equal(collection._isInsecure(), true);\n\n    if (insecurePackage) Package.insecure = insecurePackage;else delete Package.insecure;\n  });\n}","ast":null,"map":{"version":3,"sources":["/packages/mongo/allow_tests.js"],"names":[],"mappings":"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","file":"/packages/mongo/allow_tests.js.map","sourcesContent":["if (Meteor.isServer) {\n  // Set up allow/deny rules for test collections\n\n  var allowCollections = {};\n\n  // We create the collections in the publisher (instead of using a method or\n  // something) because if we made them with a method, we'd need to follow the\n  // method with some subscribes, and it's possible that the method call would\n  // be delayed by a wait method and the subscribe messages would be sent before\n  // it and fail due to the collection not yet existing. So we are very hacky\n  // and use a publish.\n  Meteor.publish(\"allowTests\", function (nonce, idGeneration) {\n    check(nonce, String);\n    check(idGeneration, String);\n    var cursors = [];\n    var needToConfigure = undefined;\n\n    // helper for defining a collection. we are careful to create just one\n    // Mongo.Collection even if the sub body is rerun, by caching them.\n    var defineCollection = function(name, insecure, transform) {\n      var fullName = name + idGeneration + nonce;\n\n      var collection;\n      if (_.has(allowCollections, fullName)) {\n        collection = allowCollections[fullName];\n        if (needToConfigure === true)\n          throw new Error(\"collections inconsistently exist\");\n        needToConfigure = false;\n      } else {\n        collection = new Mongo.Collection(\n          fullName, {idGeneration: idGeneration, transform: transform});\n        allowCollections[fullName] = collection;\n        if (needToConfigure === false)\n          throw new Error(\"collections inconsistently don't exist\");\n        needToConfigure = true;\n        collection._insecure = insecure;\n        var m = {};\n        m[\"clear-collection-\" + fullName] = function() {\n          collection.remove({});\n        };\n        Meteor.methods(m);\n      }\n\n      cursors.push(collection.find());\n      return collection;\n    };\n\n    var insecureCollection = defineCollection(\n      \"collection-insecure\", true /*insecure*/);\n    // totally locked down collection\n    var lockedDownCollection = defineCollection(\n      \"collection-locked-down\", false /*insecure*/);\n    // restricted collection with same allowed modifications, both with and\n    // without the `insecure` package\n    var restrictedCollectionDefaultSecure = defineCollection(\n      \"collection-restrictedDefaultSecure\", false /*insecure*/);\n    var restrictedCollectionDefaultInsecure = defineCollection(\n      \"collection-restrictedDefaultInsecure\", true /*insecure*/);\n    var restrictedCollectionForUpdateOptionsTest = defineCollection(\n      \"collection-restrictedForUpdateOptionsTest\", true /*insecure*/);\n    var restrictedCollectionForPartialAllowTest = defineCollection(\n      \"collection-restrictedForPartialAllowTest\", true /*insecure*/);\n    var restrictedCollectionForPartialDenyTest = defineCollection(\n      \"collection-restrictedForPartialDenyTest\", true /*insecure*/);\n    var restrictedCollectionForFetchTest = defineCollection(\n      \"collection-restrictedForFetchTest\", true /*insecure*/);\n    var restrictedCollectionForFetchAllTest = defineCollection(\n      \"collection-restrictedForFetchAllTest\", true /*insecure*/);\n    var restrictedCollectionWithTransform = defineCollection(\n      \"withTransform\", false, function (doc) {\n        return doc.a;\n      });\n    var restrictedCollectionForInvalidTransformTest = defineCollection(\n      \"collection-restrictedForInvalidTransform\", false /*insecure*/);\n    var restrictedCollectionForClientIdTest = defineCollection(\n      \"collection-restrictedForClientIdTest\", false /*insecure*/);\n\n    if (needToConfigure) {\n      restrictedCollectionWithTransform.allow({\n        insert: function (userId, doc) {\n          return doc.foo === \"foo\";\n        },\n        update: function (userId, doc) {\n          return doc.foo === \"foo\";\n        },\n        remove: function (userId, doc) {\n          return doc.bar === \"bar\";\n        }\n      });\n      restrictedCollectionWithTransform.allow({\n        // transform: null means that doc here is the top level, not the 'a'\n        // element.\n        transform: null,\n        insert: function (userId, doc) {\n          return !!doc.topLevelField;\n        },\n        update: function (userId, doc) {\n          return !!doc.topLevelField;\n        }\n      });\n      restrictedCollectionForInvalidTransformTest.allow({\n        // transform must return an object which is not a mongo id\n        transform: function (doc) { return doc._id; },\n        insert: function () { return true; }\n      });\n      restrictedCollectionForClientIdTest.allow({\n        // This test just requires the collection to trigger the restricted\n        // case.\n        insert: function () { return true; }\n      });\n\n      // two calls to allow to verify that either validator is sufficient.\n      var allows = [{\n        insert: function(userId, doc) {\n          return doc.canInsert;\n        },\n        update: function(userId, doc) {\n          return doc.canUpdate;\n        },\n        remove: function (userId, doc) {\n          return doc.canRemove;\n        }\n      }, {\n        insert: function(userId, doc) {\n          return doc.canInsert2;\n        },\n        update: function(userId, doc, fields, modifier) {\n          return -1 !== _.indexOf(fields, 'canUpdate2');\n        },\n        remove: function(userId, doc) {\n          return doc.canRemove2;\n        }\n      }];\n\n      // two calls to deny to verify that either one blocks the change.\n      var denies = [{\n        insert: function(userId, doc) {\n          return doc.cantInsert;\n        },\n        remove: function (userId, doc) {\n          return doc.cantRemove;\n        }\n      }, {\n        insert: function(userId, doc) {\n          // Don't allow explicit ID to be set by the client.\n          return _.has(doc, '_id');\n        },\n        update: function(userId, doc, fields, modifier) {\n          return -1 !== _.indexOf(fields, 'verySecret');\n        }\n      }];\n\n      _.each([\n        restrictedCollectionDefaultSecure,\n        restrictedCollectionDefaultInsecure,\n        restrictedCollectionForUpdateOptionsTest\n      ], function (collection) {\n        _.each(allows, function (allow) {\n          collection.allow(allow);\n        });\n        _.each(denies, function (deny) {\n          collection.deny(deny);\n        });\n      });\n\n      // just restrict one operation so that we can verify that others\n      // fail\n      restrictedCollectionForPartialAllowTest.allow({\n        insert: function() {}\n      });\n      restrictedCollectionForPartialDenyTest.deny({\n        insert: function() {}\n      });\n\n      // verify that we only fetch the fields specified - we should\n      // be fetching just field1, field2, and field3.\n      restrictedCollectionForFetchTest.allow({\n        insert: function() { return true; },\n        update: function(userId, doc) {\n          // throw fields in doc so that we can inspect them in test\n          throw new Meteor.Error(\n            999, \"Test: Fields in doc: \" + _.keys(doc).sort().join(','));\n        },\n        remove: function(userId, doc) {\n          // throw fields in doc so that we can inspect them in test\n          throw new Meteor.Error(\n            999, \"Test: Fields in doc: \" + _.keys(doc).sort().join(','));\n        },\n        fetch: ['field1']\n      });\n      restrictedCollectionForFetchTest.allow({\n        fetch: ['field2']\n      });\n      restrictedCollectionForFetchTest.deny({\n        fetch: ['field3']\n      });\n\n      // verify that not passing fetch to one of the calls to allow\n      // causes all fields to be fetched\n      restrictedCollectionForFetchAllTest.allow({\n        insert: function() { return true; },\n        update: function(userId, doc) {\n          // throw fields in doc so that we can inspect them in test\n          throw new Meteor.Error(\n            999, \"Test: Fields in doc: \" + _.keys(doc).sort().join(','));\n        },\n        remove: function(userId, doc) {\n          // throw fields in doc so that we can inspect them in test\n          throw new Meteor.Error(\n            999, \"Test: Fields in doc: \" + _.keys(doc).sort().join(','));\n        },\n        fetch: ['field1']\n      });\n      restrictedCollectionForFetchAllTest.allow({\n        update: function() { return true; }\n      });\n    }\n\n    return cursors;\n  });\n}\n\nif (Meteor.isClient) {\n  _.each(['STRING', 'MONGO'], function (idGeneration) {\n    // Set up a bunch of test collections... on the client! They match the ones\n    // created by setUpAllowTestsCollections.\n\n    var nonce = Random.id();\n    // Tell the server to make, configure, and publish a set of collections unique\n    // to our test run. Since the method does not unblock, this will complete\n    // running on the server before anything else happens.\n    Meteor.subscribe('allowTests', nonce, idGeneration);\n\n    // helper for defining a collection, subscribing to it, and defining\n    // a method to clear it\n    var defineCollection = function(name, transform) {\n      var fullName = name + idGeneration + nonce;\n      var collection = new Mongo.Collection(\n        fullName, {idGeneration: idGeneration, transform: transform});\n\n      collection.callClearMethod = function (callback) {\n        Meteor.call(\"clear-collection-\" + fullName, callback);\n      };\n      collection.unnoncedName = name + idGeneration;\n      return collection;\n    };\n\n    // totally insecure collection\n    var insecureCollection = defineCollection(\"collection-insecure\");\n\n    // totally locked down collection\n    var lockedDownCollection = defineCollection(\"collection-locked-down\");\n\n    // restricted collection with same allowed modifications, both with and\n    // without the `insecure` package\n    var restrictedCollectionDefaultSecure = defineCollection(\n      \"collection-restrictedDefaultSecure\");\n    var restrictedCollectionDefaultInsecure = defineCollection(\n      \"collection-restrictedDefaultInsecure\");\n    var restrictedCollectionForUpdateOptionsTest = defineCollection(\n      \"collection-restrictedForUpdateOptionsTest\");\n    var restrictedCollectionForPartialAllowTest = defineCollection(\n      \"collection-restrictedForPartialAllowTest\");\n    var restrictedCollectionForPartialDenyTest = defineCollection(\n      \"collection-restrictedForPartialDenyTest\");\n    var restrictedCollectionForFetchTest = defineCollection(\n      \"collection-restrictedForFetchTest\");\n    var restrictedCollectionForFetchAllTest = defineCollection(\n      \"collection-restrictedForFetchAllTest\");\n    var restrictedCollectionWithTransform = defineCollection(\n      \"withTransform\", function (doc) {\n        return doc.a;\n      });\n    var restrictedCollectionForInvalidTransformTest = defineCollection(\n      \"collection-restrictedForInvalidTransform\");\n    var restrictedCollectionForClientIdTest = defineCollection(\n      \"collection-restrictedForClientIdTest\");\n\n    // test that if allow is called once then the collection is\n    // restricted, and that other mutations aren't allowed\n    testAsyncMulti(\"collection - partial allow, \" + idGeneration, [\n      function (test, expect) {\n        restrictedCollectionForPartialAllowTest.update(\n          'foo', {$set: {updated: true}}, expect(function (err, res) {\n            test.equal(err.error, 403);\n          }));\n      }\n    ]);\n\n    // test that if deny is called once then the collection is\n    // restricted, and that other mutations aren't allowed\n    testAsyncMulti(\"collection - partial deny, \" + idGeneration, [\n      function (test, expect) {\n        restrictedCollectionForPartialDenyTest.update(\n          'foo', {$set: {updated: true}}, expect(function (err, res) {\n            test.equal(err.error, 403);\n          }));\n      }\n    ]);\n\n\n    // test that we only fetch the fields specified\n    testAsyncMulti(\"collection - fetch, \" + idGeneration, [\n      function (test, expect) {\n        var fetchId = restrictedCollectionForFetchTest.insert(\n          {field1: 1, field2: 1, field3: 1, field4: 1});\n        var fetchAllId = restrictedCollectionForFetchAllTest.insert(\n          {field1: 1, field2: 1, field3: 1, field4: 1});\n        restrictedCollectionForFetchTest.update(\n          fetchId, {$set: {updated: true}}, expect(function (err, res) {\n            test.equal(err.reason,\n                       \"Test: Fields in doc: _id,field1,field2,field3\");\n          }));\n        restrictedCollectionForFetchTest.remove(\n          fetchId, expect(function (err, res) {\n            test.equal(err.reason,\n                       \"Test: Fields in doc: _id,field1,field2,field3\");\n          }));\n\n        restrictedCollectionForFetchAllTest.update(\n          fetchAllId, {$set: {updated: true}}, expect(function (err, res) {\n            test.equal(err.reason,\n                       \"Test: Fields in doc: _id,field1,field2,field3,field4\");\n          }));\n        restrictedCollectionForFetchAllTest.remove(\n          fetchAllId, expect(function (err, res) {\n            test.equal(err.reason,\n                       \"Test: Fields in doc: _id,field1,field2,field3,field4\");\n          }));\n      }\n    ]);\n\n    (function(){\n      testAsyncMulti(\"collection - restricted factories \" + idGeneration, [\n        function (test, expect) {\n          restrictedCollectionWithTransform.callClearMethod(expect(function () {\n            test.equal(restrictedCollectionWithTransform.find().count(), 0);\n          }));\n        },\n        function (test, expect) {\n          var self = this;\n          restrictedCollectionWithTransform.insert({\n            a: {foo: \"foo\", bar: \"bar\", baz: \"baz\"}\n          }, expect(function (e, res) {\n            test.isFalse(e);\n            test.isTrue(res);\n            self.item1 = res;\n          }));\n          restrictedCollectionWithTransform.insert({\n            a: {foo: \"foo\", bar: \"quux\", baz: \"quux\"},\n            b: \"potato\"\n          }, expect(function (e, res) {\n            test.isFalse(e);\n            test.isTrue(res);\n            self.item2 = res;\n          }));\n          restrictedCollectionWithTransform.insert({\n            a: {foo: \"adsfadf\", bar: \"quux\", baz: \"quux\"},\n            b: \"potato\"\n          }, expect(function (e, res) {\n            test.isTrue(e);\n          }));\n          restrictedCollectionWithTransform.insert({\n            a: {foo: \"bar\"},\n            topLevelField: true\n          }, expect(function (e, res) {\n            test.isFalse(e);\n            test.isTrue(res);\n            self.item3 = res;\n          }));\n        },\n        function (test, expect) {\n          var self = this;\n          // This should work, because there is an update allow for things with\n          // topLevelField.\n          restrictedCollectionWithTransform.update(\n            self.item3, { $set: { xxx: true } }, expect(function (e, res) {\n              test.isFalse(e);\n              test.equal(1, res);\n            }));\n        },\n        function (test, expect) {\n          var self = this;\n          test.equal(\n            restrictedCollectionWithTransform.findOne(self.item1),\n            {_id: self.item1, foo: \"foo\", bar: \"bar\", baz: \"baz\"});\n          restrictedCollectionWithTransform.remove(\n            self.item1, expect(function (e, res) {\n              test.isFalse(e);\n            }));\n          restrictedCollectionWithTransform.remove(\n            self.item2, expect(function (e, res) {\n              test.isTrue(e);\n            }));\n        }\n      ]);\n    })();\n\n    testAsyncMulti(\"collection - insecure, \" + idGeneration, [\n      function (test, expect) {\n        insecureCollection.callClearMethod(expect(function () {\n          test.equal(insecureCollection.find().count(), 0);\n        }));\n      },\n      function (test, expect) {\n        var id = insecureCollection.insert({foo: 'bar'}, expect(function(err, res) {\n          test.equal(res, id);\n          test.equal(insecureCollection.find(id).count(), 1);\n          test.equal(insecureCollection.findOne(id).foo, 'bar');\n        }));\n        test.equal(insecureCollection.find(id).count(), 1);\n        test.equal(insecureCollection.findOne(id).foo, 'bar');\n      }\n    ]);\n\n    testAsyncMulti(\"collection - locked down, \" + idGeneration, [\n      function (test, expect) {\n        lockedDownCollection.callClearMethod(expect(function() {\n          test.equal(lockedDownCollection.find().count(), 0);\n        }));\n      },\n      function (test, expect) {\n        lockedDownCollection.insert({foo: 'bar'}, expect(function (err, res) {\n          test.equal(err.error, 403);\n          test.equal(lockedDownCollection.find().count(), 0);\n        }));\n      }\n    ]);\n\n    (function () {\n      var collection = restrictedCollectionForUpdateOptionsTest;\n      var id1, id2;\n      testAsyncMulti(\"collection - update options, \" + idGeneration, [\n        // init\n        function (test, expect) {\n          collection.callClearMethod(expect(function () {\n            test.equal(collection.find().count(), 0);\n          }));\n        },\n        // put a few objects\n        function (test, expect) {\n          var doc = {canInsert: true, canUpdate: true};\n          id1 = collection.insert(doc);\n          id2 = collection.insert(doc);\n          collection.insert(doc);\n          collection.insert(doc, expect(function (err, res) {\n            test.isFalse(err);\n            test.equal(collection.find().count(), 4);\n          }));\n        },\n        // update by id\n        function (test, expect) {\n          collection.update(\n            id1,\n            {$set: {updated: true}},\n            expect(function (err, res) {\n              test.isFalse(err);\n              test.equal(res, 1);\n              test.equal(collection.find({updated: true}).count(), 1);\n            }));\n        },\n        // update by id in an object\n        function (test, expect) {\n          collection.update(\n            {_id: id2},\n            {$set: {updated: true}},\n            expect(function (err, res) {\n              test.isFalse(err);\n              test.equal(res, 1);\n              test.equal(collection.find({updated: true}).count(), 2);\n            }));\n        },\n        // update with replacement operator not allowed, and has nice error.\n        function (test, expect) {\n          collection.update(\n            {_id: id2},\n            {_id: id2, updated: true},\n            expect(function (err, res) {\n              test.equal(err.error, 403);\n              test.matches(err.reason, /In a restricted/);\n              // unchanged\n              test.equal(collection.find({updated: true}).count(), 2);\n            }));\n        },\n        // upsert not allowed, and has nice error.\n        function (test, expect) {\n          collection.update(\n            {_id: id2},\n            {$set: { upserted: true }},\n            { upsert: true },\n            expect(function (err, res) {\n              test.equal(err.error, 403);\n              test.matches(err.reason, /in a restricted/);\n              test.equal(collection.find({ upserted: true }).count(), 0);\n            }));\n        },\n        // update with rename operator not allowed, and has nice error.\n        function (test, expect) {\n          collection.update(\n            {_id: id2},\n            {$rename: {updated: 'asdf'}},\n            expect(function (err, res) {\n              test.equal(err.error, 403);\n              test.matches(err.reason, /not allowed/);\n              // unchanged\n              test.equal(collection.find({updated: true}).count(), 2);\n            }));\n        },\n        // update method with a non-ID selector is not allowed\n        function (test, expect) {\n          // We shouldn't even send the method...\n          test.throws(function () {\n            collection.update(\n              {updated: {$exists: false}},\n              {$set: {updated: true}});\n          });\n          // ... but if we did, the server would reject it too.\n          Meteor.call(\n            '/' + collection._name + '/update',\n            {updated: {$exists: false}},\n            {$set: {updated: true}},\n            expect(function (err, res) {\n              test.equal(err.error, 403);\n              // unchanged\n              test.equal(collection.find({updated: true}).count(), 2);\n            }));\n        },\n        // make sure it doesn't think that {_id: 'foo', something: else} is ok.\n        function (test, expect) {\n          test.throws(function () {\n            collection.update(\n              {_id: id1, updated: {$exists: false}},\n              {$set: {updated: true}});\n          });\n        },\n        // remove method with a non-ID selector is not allowed\n        function (test, expect) {\n          // We shouldn't even send the method...\n          test.throws(function () {\n            collection.remove({updated: true});\n          });\n          // ... but if we did, the server would reject it too.\n          Meteor.call(\n            '/' + collection._name + '/remove',\n            {updated: true},\n            expect(function (err, res) {\n              test.equal(err.error, 403);\n              // unchanged\n              test.equal(collection.find({updated: true}).count(), 2);\n            }));\n        }\n      ]);\n    }) ();\n\n    _.each(\n      [restrictedCollectionDefaultInsecure, restrictedCollectionDefaultSecure],\n      function(collection) {\n        var canUpdateId, canRemoveId;\n\n        testAsyncMulti(\"collection - \" + collection.unnoncedName, [\n          // init\n          function (test, expect) {\n            collection.callClearMethod(expect(function () {\n              test.equal(collection.find().count(), 0);\n            }));\n          },\n\n          // insert with no allows passing. request is denied.\n          function (test, expect) {\n            collection.insert(\n              {},\n              expect(function (err, res) {\n                test.equal(err.error, 403);\n                test.equal(collection.find().count(), 0);\n              }));\n          },\n          // insert with one allow and one deny. denied.\n          function (test, expect) {\n            collection.insert(\n              {canInsert: true, cantInsert: true},\n              expect(function (err, res) {\n                test.equal(err.error, 403);\n                test.equal(collection.find().count(), 0);\n              }));\n          },\n          // insert with one allow and other deny. denied.\n          function (test, expect) {\n            collection.insert(\n              {canInsert: true, _id: Random.id()},\n              expect(function (err, res) {\n                test.equal(err.error, 403);\n                test.equal(collection.find().count(), 0);\n              }));\n          },\n          // insert one allow passes. allowed.\n          function (test, expect) {\n            collection.insert(\n              {canInsert: true},\n              expect(function (err, res) {\n                test.isFalse(err);\n                test.equal(collection.find().count(), 1);\n              }));\n          },\n          // insert other allow passes. allowed.\n          // includes canUpdate for later.\n          function (test, expect) {\n            canUpdateId = collection.insert(\n              {canInsert2: true, canUpdate: true},\n              expect(function (err, res) {\n                test.isFalse(err);\n                test.equal(collection.find().count(), 2);\n              }));\n          },\n          // yet a third insert executes. this one has canRemove and\n          // cantRemove set for later.\n          function (test, expect) {\n            canRemoveId = collection.insert(\n              {canInsert: true, canRemove: true, cantRemove: true},\n              expect(function (err, res) {\n                test.isFalse(err);\n                test.equal(collection.find().count(), 3);\n              }));\n          },\n\n          // can't update with a non-operator mutation\n          function (test, expect) {\n            collection.update(\n              canUpdateId, {newObject: 1},\n              expect(function (err, res) {\n                test.equal(err.error, 403);\n                test.equal(collection.find().count(), 3);\n              }));\n          },\n\n          // updating dotted fields works as if we are changing their\n          // top part\n          function (test, expect) {\n            collection.update(\n              canUpdateId, {$set: {\"dotted.field\": 1}},\n              expect(function (err, res) {\n                test.isFalse(err);\n                test.equal(res, 1);\n                test.equal(collection.findOne(canUpdateId).dotted.field, 1);\n              }));\n          },\n          function (test, expect) {\n            collection.update(\n              canUpdateId, {$set: {\"verySecret.field\": 1}},\n              expect(function (err, res) {\n                test.equal(err.error, 403);\n                test.equal(collection.find({verySecret: {$exists: true}}).count(), 0);\n              }));\n          },\n\n          // update doesn't do anything if no docs match\n          function (test, expect) {\n            collection.update(\n              \"doesn't exist\",\n              {$set: {updated: true}},\n              expect(function (err, res) {\n                test.isFalse(err);\n                test.equal(res, 0);\n                // nothing has changed\n                test.equal(collection.find().count(), 3);\n                test.equal(collection.find({updated: true}).count(), 0);\n              }));\n          },\n          // update fails when access is denied trying to set `verySecret`\n          function (test, expect) {\n            collection.update(\n              canUpdateId, {$set: {verySecret: true}},\n              expect(function (err, res) {\n                test.equal(err.error, 403);\n                // nothing has changed\n                test.equal(collection.find().count(), 3);\n                test.equal(collection.find({updated: true}).count(), 0);\n              }));\n          },\n          // update fails when trying to set two fields, one of which is\n          // `verySecret`\n          function (test, expect) {\n            collection.update(\n              canUpdateId, {$set: {updated: true, verySecret: true}},\n              expect(function (err, res) {\n                test.equal(err.error, 403);\n                // nothing has changed\n                test.equal(collection.find().count(), 3);\n                test.equal(collection.find({updated: true}).count(), 0);\n              }));\n          },\n          // update fails when trying to modify docs that don't\n          // have `canUpdate` set\n          function (test, expect) {\n            collection.update(\n              canRemoveId,\n              {$set: {updated: true}},\n              expect(function (err, res) {\n                test.equal(err.error, 403);\n                // nothing has changed\n                test.equal(collection.find().count(), 3);\n                test.equal(collection.find({updated: true}).count(), 0);\n              }));\n          },\n          // update executes when it should\n          function (test, expect) {\n            collection.update(\n              canUpdateId,\n              {$set: {updated: true}},\n              expect(function (err, res) {\n                test.isFalse(err);\n                test.equal(res, 1);\n                test.equal(collection.find({updated: true}).count(), 1);\n              }));\n          },\n\n          // remove fails when trying to modify a doc with no `canRemove` set\n          function (test, expect) {\n            collection.remove(canUpdateId,\n                              expect(function (err, res) {\n              test.equal(err.error, 403);\n              // nothing has changed\n              test.equal(collection.find().count(), 3);\n            }));\n          },\n          // remove fails when trying to modify an doc with `cantRemove`\n          // set\n          function (test, expect) {\n            collection.remove(canRemoveId,\n                              expect(function (err, res) {\n              test.equal(err.error, 403);\n              // nothing has changed\n              test.equal(collection.find().count(), 3);\n            }));\n          },\n\n          // update the doc to remove cantRemove.\n          function (test, expect) {\n            collection.update(\n              canRemoveId,\n              {$set: {cantRemove: false, canUpdate2: true}},\n              expect(function (err, res) {\n                test.isFalse(err);\n                test.equal(res, 1);\n                test.equal(collection.find({cantRemove: true}).count(), 0);\n              }));\n          },\n\n          // now remove can remove it.\n          function (test, expect) {\n            collection.remove(canRemoveId,\n                              expect(function (err, res) {\n              test.isFalse(err);\n              test.equal(res, 1);\n              // successfully removed\n              test.equal(collection.find().count(), 2);\n            }));\n          },\n\n          // try to remove a doc that doesn't exist. see we remove no docs.\n          function (test, expect) {\n            collection.remove('some-random-id-that-never-matches',\n                              expect(function (err, res) {\n              test.isFalse(err);\n              test.equal(res, 0);\n              // nothing removed\n              test.equal(collection.find().count(), 2);\n            }));\n          },\n\n          // methods can still bypass restrictions\n          function (test, expect) {\n            collection.callClearMethod(\n              expect(function (err, res) {\n                test.isFalse(err);\n                // successfully removed\n                test.equal(collection.find().count(), 0);\n            }));\n          }\n        ]);\n      });\n    testAsyncMulti(\n      \"collection - allow/deny transform must return object, \" + idGeneration,\n      [function (test, expect) {\n        restrictedCollectionForInvalidTransformTest.insert({}, expect(function (err, res) {\n          test.isTrue(err);\n        }));\n      }]);\n    testAsyncMulti(\n      \"collection - restricted collection allows client-side id, \" + idGeneration,\n      [function (test, expect) {\n        var self = this;\n        self.id = Random.id();\n        restrictedCollectionForClientIdTest.insert({_id: self.id}, expect(function (err, res) {\n          test.isFalse(err);\n          test.equal(res, self.id);\n          test.equal(restrictedCollectionForClientIdTest.findOne(self.id),\n                     {_id: self.id});\n        }));\n      }]);\n  });  // end idGeneration loop\n}  // end if isClient\n\n\n\n// A few simple server-only tests which don't need to coordinate collections\n// with the client..\nif (Meteor.isServer) {\n  Tinytest.add(\"collection - allow and deny validate options\", function (test) {\n    var collection = new Mongo.Collection(null);\n\n    test.throws(function () {\n      collection.allow({invalidOption: true});\n    });\n    test.throws(function () {\n      collection.deny({invalidOption: true});\n    });\n\n    _.each(['insert', 'update', 'remove', 'fetch'], function (key) {\n      var options = {};\n      options[key] = true;\n      test.throws(function () {\n        collection.allow(options);\n      });\n      test.throws(function () {\n        collection.deny(options);\n      });\n    });\n\n    _.each(['insert', 'update', 'remove'], function (key) {\n      var options = {};\n      options[key] = false;\n      test.throws(function () {\n        collection.allow(options);\n      });\n      test.throws(function () {\n        collection.deny(options);\n      });\n    });\n\n    _.each(['insert', 'update', 'remove'], function (key) {\n      var options = {};\n      options[key] = undefined;\n      test.throws(function () {\n        collection.allow(options);\n      });\n      test.throws(function () {\n        collection.deny(options);\n      });\n    });\n\n    _.each(['insert', 'update', 'remove'], function (key) {\n      var options = {};\n      options[key] = ['an array']; // this should be a function, not an array\n      test.throws(function () {\n        collection.allow(options);\n      });\n      test.throws(function () {\n        collection.deny(options);\n      });\n    });\n\n    test.throws(function () {\n      collection.allow({fetch: function () {}}); // this should be an array\n    });\n  });\n\n  Tinytest.add(\"collection - calling allow restricts\", function (test) {\n    var collection = new Mongo.Collection(null);\n    test.equal(collection._restricted, false);\n    collection.allow({\n      insert: function() {}\n    });\n    test.equal(collection._restricted, true);\n  });\n\n  Tinytest.add(\"collection - global insecure\", function (test) {\n    // note: This test alters the global insecure status, by sneakily hacking\n    // the global Package object!\n    var insecurePackage = Package.insecure;\n\n    Package.insecure = {};\n    var collection = new Mongo.Collection(null);\n    test.equal(collection._isInsecure(), true);\n\n    Package.insecure = undefined;\n    test.equal(collection._isInsecure(), false);\n\n    delete Package.insecure;\n    test.equal(collection._isInsecure(), false);\n\n    collection._insecure = true;\n    test.equal(collection._isInsecure(), true);\n\n    if (insecurePackage)\n      Package.insecure = insecurePackage;\n    else\n      delete Package.insecure;\n  });\n}\n"]},"hash":"efff6b97b82369feddd52a193c8c0be714ae4fe9"}
