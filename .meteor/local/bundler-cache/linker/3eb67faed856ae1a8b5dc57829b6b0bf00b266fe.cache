[{"type":"js","data":"//////////////////////////////////////////////////////////////////////////\n//                                                                      //\n// This is a generated file. You can view the original                  //\n// source in your browser if your browser supports source maps.         //\n// Source maps are supported by all recent versions of Chrome, Safari,  //\n// and Firefox, and by Internet Explorer 11.                            //\n//                                                                      //\n//////////////////////////////////////////////////////////////////////////\n\n\n(function () {\n\n/* Imports */\nvar Meteor = Package.meteor.Meteor;\nvar global = Package.meteor.global;\nvar meteorEnv = Package.meteor.meteorEnv;\nvar meteorInstall = Package.modules.meteorInstall;\nvar Buffer = Package.modules.Buffer;\nvar process = Package.modules.process;\nvar _ = Package.underscore._;\nvar EJSON = Package.ejson.EJSON;\n\n/* Package-scope variables */\nvar check, Match;\n\nvar require = meteorInstall({\"node_modules\":{\"meteor\":{\"check\":{\"match.js\":[\"./isPlainObject.js\",function(require,exports){\n\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                   //\n// packages/check/match.js                                                                                           //\n//                                                                                                                   //\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                     //\n// XXX docs                                                                                                          // 1\n                                                                                                                     // 2\n// Things we explicitly do NOT support:                                                                              // 3\n//    - heterogenous arrays                                                                                          // 4\n                                                                                                                     // 5\nvar currentArgumentChecker = new Meteor.EnvironmentVariable;                                                         // 6\nvar isPlainObject = require(\"./isPlainObject.js\").isPlainObject;                                                     // 7\n                                                                                                                     // 8\n/**                                                                                                                  // 9\n * @summary Check that a value matches a [pattern](#matchpatterns).                                                  // 10\n * If the value does not match the pattern, throw a `Match.Error`.                                                   // 11\n *                                                                                                                   // 12\n * Particularly useful to assert that arguments to a function have the right                                         // 13\n * types and structure.                                                                                              // 14\n * @locus Anywhere                                                                                                   // 15\n * @param {Any} value The value to check                                                                             // 16\n * @param {MatchPattern} pattern The pattern to match                                                                // 17\n * `value` against                                                                                                   // 18\n */                                                                                                                  // 19\nvar check = exports.check = function (value, pattern) {                                                              // 20\n  // Record that check got called, if somebody cared.                                                                // 21\n  //                                                                                                                 // 22\n  // We use getOrNullIfOutsideFiber so that it's OK to call check()                                                  // 23\n  // from non-Fiber server contexts; the downside is that if you forget to                                           // 24\n  // bindEnvironment on some random callback in your method/publisher,                                               // 25\n  // it might not find the argumentChecker and you'll get an error about                                             // 26\n  // not checking an argument that it looks like you're checking (instead                                            // 27\n  // of just getting a \"Node code must run in a Fiber\" error).                                                       // 28\n  var argChecker = currentArgumentChecker.getOrNullIfOutsideFiber();                                                 // 29\n  if (argChecker)                                                                                                    // 30\n    argChecker.checking(value);                                                                                      // 31\n  var result = testSubtree(value, pattern);                                                                          // 32\n  if (result) {                                                                                                      // 33\n    var err = new Match.Error(result.message);                                                                       // 34\n    if (result.path) {                                                                                               // 35\n      err.message += \" in field \" + result.path;                                                                     // 36\n      err.path = result.path;                                                                                        // 37\n    }                                                                                                                // 38\n    throw err;                                                                                                       // 39\n  }                                                                                                                  // 40\n};                                                                                                                   // 41\n                                                                                                                     // 42\n/**                                                                                                                  // 43\n * @namespace Match                                                                                                  // 44\n * @summary The namespace for all Match types and methods.                                                           // 45\n */                                                                                                                  // 46\nvar Match = exports.Match = {                                                                                        // 47\n  Optional: function (pattern) {                                                                                     // 48\n    return new Optional(pattern);                                                                                    // 49\n  },                                                                                                                 // 50\n  Maybe: function (pattern) {                                                                                        // 51\n    return new Maybe(pattern);                                                                                       // 52\n  },                                                                                                                 // 53\n  OneOf: function (/*arguments*/) {                                                                                  // 54\n    return new OneOf(_.toArray(arguments));                                                                          // 55\n  },                                                                                                                 // 56\n  Any: ['__any__'],                                                                                                  // 57\n  Where: function (condition) {                                                                                      // 58\n    return new Where(condition);                                                                                     // 59\n  },                                                                                                                 // 60\n  ObjectIncluding: function (pattern) {                                                                              // 61\n    return new ObjectIncluding(pattern);                                                                             // 62\n  },                                                                                                                 // 63\n  ObjectWithValues: function (pattern) {                                                                             // 64\n    return new ObjectWithValues(pattern);                                                                            // 65\n  },                                                                                                                 // 66\n  // Matches only signed 32-bit integers                                                                             // 67\n  Integer: ['__integer__'],                                                                                          // 68\n                                                                                                                     // 69\n  // XXX matchers should know how to describe themselves for errors                                                  // 70\n  Error: Meteor.makeErrorType(\"Match.Error\", function (msg) {                                                        // 71\n    this.message = \"Match error: \" + msg;                                                                            // 72\n    // The path of the value that failed to match. Initially empty, this gets                                        // 73\n    // populated by catching and rethrowing the exception as it goes back up the                                     // 74\n    // stack.                                                                                                        // 75\n    // E.g.: \"vals[3].entity.created\"                                                                                // 76\n    this.path = \"\";                                                                                                  // 77\n    // If this gets sent over DDP, don't give full internal details but at least                                     // 78\n    // provide something better than 500 Internal server error.                                                      // 79\n    this.sanitizedError = new Meteor.Error(400, \"Match failed\");                                                     // 80\n  }),                                                                                                                // 81\n                                                                                                                     // 82\n  // Tests to see if value matches pattern. Unlike check, it merely returns true                                     // 83\n  // or false (unless an error other than Match.Error was thrown). It does not                                       // 84\n  // interact with _failIfArgumentsAreNotAllChecked.                                                                 // 85\n  // XXX maybe also implement a Match.match which returns more information about                                     // 86\n  //     failures but without using exception handling or doing what check()                                         // 87\n  //     does with _failIfArgumentsAreNotAllChecked and Meteor.Error conversion                                      // 88\n                                                                                                                     // 89\n  /**                                                                                                                // 90\n   * @summary Returns true if the value matches the pattern.                                                         // 91\n   * @locus Anywhere                                                                                                 // 92\n   * @param {Any} value The value to check                                                                           // 93\n   * @param {MatchPattern} pattern The pattern to match `value` against                                              // 94\n   */                                                                                                                // 95\n  test: function (value, pattern) {                                                                                  // 96\n    return !testSubtree(value, pattern);                                                                             // 97\n  },                                                                                                                 // 98\n                                                                                                                     // 99\n  // Runs `f.apply(context, args)`. If check() is not called on every element of                                     // 100\n  // `args` (either directly or in the first level of an array), throws an error                                     // 101\n  // (using `description` in the message).                                                                           // 102\n  //                                                                                                                 // 103\n  _failIfArgumentsAreNotAllChecked: function (f, context, args, description) {                                       // 104\n    var argChecker = new ArgumentChecker(args, description);                                                         // 105\n    var result = currentArgumentChecker.withValue(argChecker, function () {                                          // 106\n      return f.apply(context, args);                                                                                 // 107\n    });                                                                                                              // 108\n    // If f didn't itself throw, make sure it checked all of its arguments.                                          // 109\n    argChecker.throwUnlessAllArgumentsHaveBeenChecked();                                                             // 110\n    return result;                                                                                                   // 111\n  }                                                                                                                  // 112\n};                                                                                                                   // 113\n                                                                                                                     // 114\nvar Optional = function (pattern) {                                                                                  // 115\n  this.pattern = pattern;                                                                                            // 116\n};                                                                                                                   // 117\n                                                                                                                     // 118\nvar Maybe = function (pattern) {                                                                                     // 119\n  this.pattern = pattern;                                                                                            // 120\n};                                                                                                                   // 121\n                                                                                                                     // 122\nvar OneOf = function (choices) {                                                                                     // 123\n  if (_.isEmpty(choices))                                                                                            // 124\n    throw new Error(\"Must provide at least one choice to Match.OneOf\");                                              // 125\n  this.choices = choices;                                                                                            // 126\n};                                                                                                                   // 127\n                                                                                                                     // 128\nvar Where = function (condition) {                                                                                   // 129\n  this.condition = condition;                                                                                        // 130\n};                                                                                                                   // 131\n                                                                                                                     // 132\nvar ObjectIncluding = function (pattern) {                                                                           // 133\n  this.pattern = pattern;                                                                                            // 134\n};                                                                                                                   // 135\n                                                                                                                     // 136\nvar ObjectWithValues = function (pattern) {                                                                          // 137\n  this.pattern = pattern;                                                                                            // 138\n};                                                                                                                   // 139\n                                                                                                                     // 140\nvar stringForErrorMessage = function (value, options) {                                                              // 141\n  options = options || {};                                                                                           // 142\n                                                                                                                     // 143\n  if ( value === null ) return \"null\";                                                                               // 144\n                                                                                                                     // 145\n  if ( options.onlyShowType ) {                                                                                      // 146\n    return typeof value;                                                                                             // 147\n  }                                                                                                                  // 148\n                                                                                                                     // 149\n  // Your average non-object things.  Saves from doing the try/catch below for.                                      // 150\n  if ( typeof value !== \"object\" ) {                                                                                 // 151\n    return EJSON.stringify(value)                                                                                    // 152\n  }                                                                                                                  // 153\n                                                                                                                     // 154\n  try {                                                                                                              // 155\n    // Find objects with circular references since EJSON doesn't support them yet (Issue #4778 + Unaccepted PR)      // 156\n    // If the native stringify is going to choke, EJSON.stringify is going to choke too.                             // 157\n    JSON.stringify(value);                                                                                           // 158\n  } catch (stringifyError) {                                                                                         // 159\n    if ( stringifyError.name === \"TypeError\" ) {                                                                     // 160\n      return typeof value;                                                                                           // 161\n    }                                                                                                                // 162\n  }                                                                                                                  // 163\n                                                                                                                     // 164\n  return EJSON.stringify(value);                                                                                     // 165\n};                                                                                                                   // 166\n                                                                                                                     // 167\nvar typeofChecks = [                                                                                                 // 168\n  [String, \"string\"],                                                                                                // 169\n  [Number, \"number\"],                                                                                                // 170\n  [Boolean, \"boolean\"],                                                                                              // 171\n  // While we don't allow undefined/function in EJSON, this is good for optional                                     // 172\n  // arguments with OneOf.                                                                                           // 173\n  [Function, \"function\"],                                                                                            // 174\n  [undefined, \"undefined\"]                                                                                           // 175\n];                                                                                                                   // 176\n                                                                                                                     // 177\n// Return `false` if it matches. Otherwise, return an object with a `message` and a `path` field.                    // 178\nvar testSubtree = function (value, pattern) {                                                                        // 179\n  // Match anything!                                                                                                 // 180\n  if (pattern === Match.Any)                                                                                         // 181\n    return false;                                                                                                    // 182\n                                                                                                                     // 183\n  // Basic atomic types.                                                                                             // 184\n  // Do not match boxed objects (e.g. String, Boolean)                                                               // 185\n  for (var i = 0; i < typeofChecks.length; ++i) {                                                                    // 186\n    if (pattern === typeofChecks[i][0]) {                                                                            // 187\n      if (typeof value === typeofChecks[i][1])                                                                       // 188\n        return false;                                                                                                // 189\n      return {                                                                                                       // 190\n        message: \"Expected \" + typeofChecks[i][1] + \", got \" + stringForErrorMessage(value, { onlyShowType: true }),\n        path: \"\"                                                                                                     // 192\n      };                                                                                                             // 193\n    }                                                                                                                // 194\n  }                                                                                                                  // 195\n                                                                                                                     // 196\n  if (pattern === null) {                                                                                            // 197\n    if (value === null) {                                                                                            // 198\n      return false;                                                                                                  // 199\n    }                                                                                                                // 200\n    return {                                                                                                         // 201\n      message: \"Expected null, got \" + stringForErrorMessage(value),                                                 // 202\n      path: \"\"                                                                                                       // 203\n    };                                                                                                               // 204\n  }                                                                                                                  // 205\n                                                                                                                     // 206\n  // Strings, numbers, and booleans match literally. Goes well with Match.OneOf.                                     // 207\n  if (typeof pattern === \"string\" || typeof pattern === \"number\" || typeof pattern === \"boolean\") {                  // 208\n    if (value === pattern)                                                                                           // 209\n      return false;                                                                                                  // 210\n    return {                                                                                                         // 211\n      message: \"Expected \" + pattern + \", got \" + stringForErrorMessage(value),                                      // 212\n      path: \"\"                                                                                                       // 213\n    };                                                                                                               // 214\n  }                                                                                                                  // 215\n                                                                                                                     // 216\n  // Match.Integer is special type encoded with array                                                                // 217\n  if (pattern === Match.Integer) {                                                                                   // 218\n    // There is no consistent and reliable way to check if variable is a 64-bit                                      // 219\n    // integer. One of the popular solutions is to get reminder of division by 1                                     // 220\n    // but this method fails on really large floats with big precision.                                              // 221\n    // E.g.: 1.348192308491824e+23 % 1 === 0 in V8                                                                   // 222\n    // Bitwise operators work consistantly but always cast variable to 32-bit                                        // 223\n    // signed integer according to JavaScript specs.                                                                 // 224\n    if (typeof value === \"number\" && (value | 0) === value)                                                          // 225\n      return false;                                                                                                  // 226\n    return {                                                                                                         // 227\n      message: \"Expected Integer, got \" + stringForErrorMessage(value),                                              // 228\n      path: \"\"                                                                                                       // 229\n    };                                                                                                               // 230\n  }                                                                                                                  // 231\n                                                                                                                     // 232\n  // \"Object\" is shorthand for Match.ObjectIncluding({});                                                            // 233\n  if (pattern === Object)                                                                                            // 234\n    pattern = Match.ObjectIncluding({});                                                                             // 235\n                                                                                                                     // 236\n  // Array (checked AFTER Any, which is implemented as an Array).                                                    // 237\n  if (pattern instanceof Array) {                                                                                    // 238\n    if (pattern.length !== 1) {                                                                                      // 239\n      return {                                                                                                       // 240\n        message: \"Bad pattern: arrays must have one type element\" + stringForErrorMessage(pattern),                  // 241\n        path: \"\"                                                                                                     // 242\n      };                                                                                                             // 243\n    }                                                                                                                // 244\n    if (!_.isArray(value) && !_.isArguments(value)) {                                                                // 245\n      return {                                                                                                       // 246\n        message: \"Expected array, got \" + stringForErrorMessage(value),                                              // 247\n        path: \"\"                                                                                                     // 248\n      };                                                                                                             // 249\n    }                                                                                                                // 250\n                                                                                                                     // 251\n    for (var i = 0, length = value.length; i < length; i++) {                                                        // 252\n      var result = testSubtree(value[i], pattern[0]);                                                                // 253\n      if (result) {                                                                                                  // 254\n        result.path = _prependPath(i, result.path);                                                                  // 255\n        return result;                                                                                               // 256\n      }                                                                                                              // 257\n    }                                                                                                                // 258\n    return false;                                                                                                    // 259\n  }                                                                                                                  // 260\n                                                                                                                     // 261\n  // Arbitrary validation checks. The condition can return false or throw a                                          // 262\n  // Match.Error (ie, it can internally use check()) to fail.                                                        // 263\n  if (pattern instanceof Where) {                                                                                    // 264\n    var result;                                                                                                      // 265\n    try {                                                                                                            // 266\n      result = pattern.condition(value);                                                                             // 267\n    } catch (err) {                                                                                                  // 268\n      if (!(err instanceof Match.Error))                                                                             // 269\n        throw err;                                                                                                   // 270\n      return {                                                                                                       // 271\n        message: err.message,                                                                                        // 272\n        path: err.path                                                                                               // 273\n      };                                                                                                             // 274\n    }                                                                                                                // 275\n    if (result)                                                                                                      // 276\n      return false;                                                                                                  // 277\n    // XXX this error is terrible                                                                                    // 278\n    return {                                                                                                         // 279\n      message: \"Failed Match.Where validation\",                                                                      // 280\n      path: \"\"                                                                                                       // 281\n    };                                                                                                               // 282\n  }                                                                                                                  // 283\n                                                                                                                     // 284\n                                                                                                                     // 285\n  if (pattern instanceof Maybe) {                                                                                    // 286\n    pattern = Match.OneOf(undefined, null, pattern.pattern);                                                         // 287\n  }                                                                                                                  // 288\n  else if (pattern instanceof Optional) {                                                                            // 289\n    pattern = Match.OneOf(undefined, pattern.pattern);                                                               // 290\n  }                                                                                                                  // 291\n                                                                                                                     // 292\n  if (pattern instanceof OneOf) {                                                                                    // 293\n    for (var i = 0; i < pattern.choices.length; ++i) {                                                               // 294\n      var result = testSubtree(value, pattern.choices[i]);                                                           // 295\n      if (!result) {                                                                                                 // 296\n        // No error? Yay, return.                                                                                    // 297\n        return false;                                                                                                // 298\n      }                                                                                                              // 299\n      // Match errors just mean try another choice.                                                                  // 300\n    }                                                                                                                // 301\n    // XXX this error is terrible                                                                                    // 302\n    return {                                                                                                         // 303\n      message: \"Failed Match.OneOf, Match.Maybe or Match.Optional validation\",                                       // 304\n      path: \"\"                                                                                                       // 305\n    };                                                                                                               // 306\n  }                                                                                                                  // 307\n                                                                                                                     // 308\n  // A function that isn't something we special-case is assumed to be a                                              // 309\n  // constructor.                                                                                                    // 310\n  if (pattern instanceof Function) {                                                                                 // 311\n    if (value instanceof pattern)                                                                                    // 312\n      return false;                                                                                                  // 313\n    return {                                                                                                         // 314\n      message: \"Expected \" + (pattern.name ||\"particular constructor\"),                                              // 315\n      path: \"\"                                                                                                       // 316\n    };                                                                                                               // 317\n  }                                                                                                                  // 318\n                                                                                                                     // 319\n  var unknownKeysAllowed = false;                                                                                    // 320\n  var unknownKeyPattern;                                                                                             // 321\n  if (pattern instanceof ObjectIncluding) {                                                                          // 322\n    unknownKeysAllowed = true;                                                                                       // 323\n    pattern = pattern.pattern;                                                                                       // 324\n  }                                                                                                                  // 325\n  if (pattern instanceof ObjectWithValues) {                                                                         // 326\n    unknownKeysAllowed = true;                                                                                       // 327\n    unknownKeyPattern = [pattern.pattern];                                                                           // 328\n    pattern = {};  // no required keys                                                                               // 329\n  }                                                                                                                  // 330\n                                                                                                                     // 331\n  if (typeof pattern !== \"object\") {                                                                                 // 332\n    return {                                                                                                         // 333\n      message: \"Bad pattern: unknown pattern type\",                                                                  // 334\n      path: \"\"                                                                                                       // 335\n    };                                                                                                               // 336\n  }                                                                                                                  // 337\n                                                                                                                     // 338\n  // An object, with required and optional keys. Note that this does NOT do                                          // 339\n  // structural matches against objects of special types that happen to match                                        // 340\n  // the pattern: this really needs to be a plain old {Object}!                                                      // 341\n  if (typeof value !== 'object') {                                                                                   // 342\n    return {                                                                                                         // 343\n      message: \"Expected object, got \" + typeof value,                                                               // 344\n      path: \"\"                                                                                                       // 345\n    };                                                                                                               // 346\n  }                                                                                                                  // 347\n  if (value === null) {                                                                                              // 348\n    return {                                                                                                         // 349\n      message: \"Expected object, got null\",                                                                          // 350\n      path: \"\"                                                                                                       // 351\n    };                                                                                                               // 352\n  }                                                                                                                  // 353\n  if (! isPlainObject(value)) {                                                                                      // 354\n    return {                                                                                                         // 355\n      message: \"Expected plain object\",                                                                              // 356\n      path: \"\"                                                                                                       // 357\n    };                                                                                                               // 358\n  }                                                                                                                  // 359\n                                                                                                                     // 360\n  var requiredPatterns = {};                                                                                         // 361\n  var optionalPatterns = {};                                                                                         // 362\n  _.each(pattern, function (subPattern, key) {                                                                       // 363\n    if (subPattern instanceof Optional || subPattern instanceof Maybe)                                               // 364\n      optionalPatterns[key] = subPattern.pattern;                                                                    // 365\n    else                                                                                                             // 366\n      requiredPatterns[key] = subPattern;                                                                            // 367\n  });                                                                                                                // 368\n                                                                                                                     // 369\n  //XXX: replace with underscore's _.allKeys if Meteor updates underscore to 1.8+ (or lodash)                        // 370\n  var allKeys = function(obj){                                                                                       // 371\n    var keys = [];                                                                                                   // 372\n    if (_.isObject(obj)){                                                                                            // 373\n      for (var key in obj) keys.push(key);                                                                           // 374\n    }                                                                                                                // 375\n    return keys;                                                                                                     // 376\n  }                                                                                                                  // 377\n                                                                                                                     // 378\n  for (var keys = allKeys(value), i = 0, length = keys.length; i < length; i++) {                                    // 379\n    var key = keys[i];                                                                                               // 380\n    var subValue = value[key];                                                                                       // 381\n    if (_.has(requiredPatterns, key)) {                                                                              // 382\n      var result = testSubtree(subValue, requiredPatterns[key]);                                                     // 383\n      if (result) {                                                                                                  // 384\n        result.path = _prependPath(key, result.path);                                                                // 385\n        return result;                                                                                               // 386\n      }                                                                                                              // 387\n      delete requiredPatterns[key];                                                                                  // 388\n    } else if (_.has(optionalPatterns, key)) {                                                                       // 389\n      var result = testSubtree(subValue, optionalPatterns[key]);                                                     // 390\n      if (result) {                                                                                                  // 391\n        result.path = _prependPath(key, result.path);                                                                // 392\n        return result;                                                                                               // 393\n      }                                                                                                              // 394\n    } else {                                                                                                         // 395\n      if (!unknownKeysAllowed) {                                                                                     // 396\n        return {                                                                                                     // 397\n          message: \"Unknown key\",                                                                                    // 398\n          path: key                                                                                                  // 399\n        };                                                                                                           // 400\n      }                                                                                                              // 401\n      if (unknownKeyPattern) {                                                                                       // 402\n        var result = testSubtree(subValue, unknownKeyPattern[0]);                                                    // 403\n        if (result) {                                                                                                // 404\n          result.path = _prependPath(key, result.path);                                                              // 405\n          return result;                                                                                             // 406\n        }                                                                                                            // 407\n      }                                                                                                              // 408\n    }                                                                                                                // 409\n  }                                                                                                                  // 410\n                                                                                                                     // 411\n  var keys = _.keys(requiredPatterns);                                                                               // 412\n  if (keys.length) {                                                                                                 // 413\n    return {                                                                                                         // 414\n      message: \"Missing key '\" + keys[0] + \"'\",                                                                      // 415\n      path: \"\"                                                                                                       // 416\n    };                                                                                                               // 417\n  }                                                                                                                  // 418\n};                                                                                                                   // 419\n                                                                                                                     // 420\nvar ArgumentChecker = function (args, description) {                                                                 // 421\n  var self = this;                                                                                                   // 422\n  // Make a SHALLOW copy of the arguments. (We'll be doing identity checks                                           // 423\n  // against its contents.)                                                                                          // 424\n  self.args = _.clone(args);                                                                                         // 425\n  // Since the common case will be to check arguments in order, and we splice                                        // 426\n  // out arguments when we check them, make it so we splice out from the end                                         // 427\n  // rather than the beginning.                                                                                      // 428\n  self.args.reverse();                                                                                               // 429\n  self.description = description;                                                                                    // 430\n};                                                                                                                   // 431\n                                                                                                                     // 432\n_.extend(ArgumentChecker.prototype, {                                                                                // 433\n  checking: function (value) {                                                                                       // 434\n    var self = this;                                                                                                 // 435\n    if (self._checkingOneValue(value))                                                                               // 436\n      return;                                                                                                        // 437\n    // Allow check(arguments, [String]) or check(arguments.slice(1), [String])                                       // 438\n    // or check([foo, bar], [String]) to count... but only if value wasn't                                           // 439\n    // itself an argument.                                                                                           // 440\n    if (_.isArray(value) || _.isArguments(value)) {                                                                  // 441\n      _.each(value, _.bind(self._checkingOneValue, self));                                                           // 442\n    }                                                                                                                // 443\n  },                                                                                                                 // 444\n  _checkingOneValue: function (value) {                                                                              // 445\n    var self = this;                                                                                                 // 446\n    for (var i = 0; i < self.args.length; ++i) {                                                                     // 447\n      // Is this value one of the arguments? (This can have a false positive if                                      // 448\n      // the argument is an interned primitive, but it's still a good enough                                         // 449\n      // check.)                                                                                                     // 450\n      // (NaN is not === to itself, so we have to check specially.)                                                  // 451\n      if (value === self.args[i] || (_.isNaN(value) && _.isNaN(self.args[i]))) {                                     // 452\n        self.args.splice(i, 1);                                                                                      // 453\n        return true;                                                                                                 // 454\n      }                                                                                                              // 455\n    }                                                                                                                // 456\n    return false;                                                                                                    // 457\n  },                                                                                                                 // 458\n  throwUnlessAllArgumentsHaveBeenChecked: function () {                                                              // 459\n    var self = this;                                                                                                 // 460\n    if (!_.isEmpty(self.args))                                                                                       // 461\n      throw new Error(\"Did not check() all arguments during \" +                                                      // 462\n                      self.description);                                                                             // 463\n  }                                                                                                                  // 464\n});                                                                                                                  // 465\n                                                                                                                     // 466\nvar _jsKeywords = [\"do\", \"if\", \"in\", \"for\", \"let\", \"new\", \"try\", \"var\", \"case\",                                      // 467\n  \"else\", \"enum\", \"eval\", \"false\", \"null\", \"this\", \"true\", \"void\", \"with\",                                           // 468\n  \"break\", \"catch\", \"class\", \"const\", \"super\", \"throw\", \"while\", \"yield\",                                            // 469\n  \"delete\", \"export\", \"import\", \"public\", \"return\", \"static\", \"switch\",                                              // 470\n  \"typeof\", \"default\", \"extends\", \"finally\", \"package\", \"private\", \"continue\",                                       // 471\n  \"debugger\", \"function\", \"arguments\", \"interface\", \"protected\", \"implements\",                                       // 472\n  \"instanceof\"];                                                                                                     // 473\n                                                                                                                     // 474\n// Assumes the base of path is already escaped properly                                                              // 475\n// returns key + base                                                                                                // 476\nvar _prependPath = function (key, base) {                                                                            // 477\n  if ((typeof key) === \"number\" || key.match(/^[0-9]+$/))                                                            // 478\n    key = \"[\" + key + \"]\";                                                                                           // 479\n  else if (!key.match(/^[a-z_$][0-9a-z_$]*$/i) || _.contains(_jsKeywords, key))                                      // 480\n    key = JSON.stringify([key]);                                                                                     // 481\n                                                                                                                     // 482\n  if (base && base[0] !== \"[\")                                                                                       // 483\n    return key + '.' + base;                                                                                         // 484\n  return key + base;                                                                                                 // 485\n};                                                                                                                   // 486\n                                                                                                                     // 487\n                                                                                                                     // 488\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}],\"isPlainObject.js\":function(require,exports){\n\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                   //\n// packages/check/isPlainObject.js                                                                                   //\n//                                                                                                                   //\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                     //\n// Copy of jQuery.isPlainObject for the server side from jQuery v1.11.2.                                             // 1\n                                                                                                                     // 2\nvar class2type = {};                                                                                                 // 3\n                                                                                                                     // 4\nvar toString = class2type.toString;                                                                                  // 5\n                                                                                                                     // 6\nvar hasOwn = class2type.hasOwnProperty;                                                                              // 7\n                                                                                                                     // 8\nvar support = {};                                                                                                    // 9\n                                                                                                                     // 10\n// Populate the class2type map                                                                                       // 11\n_.each(\"Boolean Number String Function Array Date RegExp Object Error\".split(\" \"), function(name, i) {               // 12\n  class2type[ \"[object \" + name + \"]\" ] = name.toLowerCase();                                                        // 13\n});                                                                                                                  // 14\n                                                                                                                     // 15\nfunction type( obj ) {                                                                                               // 16\n  if ( obj == null ) {                                                                                               // 17\n    return obj + \"\";                                                                                                 // 18\n  }                                                                                                                  // 19\n  return typeof obj === \"object\" || typeof obj === \"function\" ?                                                      // 20\n    class2type[ toString.call(obj) ] || \"object\" :                                                                   // 21\n    typeof obj;                                                                                                      // 22\n}                                                                                                                    // 23\n                                                                                                                     // 24\nfunction isWindow( obj ) {                                                                                           // 25\n  /* jshint eqeqeq: false */                                                                                         // 26\n  return obj != null && obj == obj.window;                                                                           // 27\n}                                                                                                                    // 28\n                                                                                                                     // 29\nexports.isPlainObject = function( obj ) {                                                                            // 30\n  var key;                                                                                                           // 31\n                                                                                                                     // 32\n  // Must be an Object.                                                                                              // 33\n  // Because of IE, we also have to check the presence of the constructor property.                                  // 34\n  // Make sure that DOM nodes and window objects don't pass through, as well                                         // 35\n  if ( !obj || type(obj) !== \"object\" || obj.nodeType || isWindow( obj ) ) {                                         // 36\n    return false;                                                                                                    // 37\n  }                                                                                                                  // 38\n                                                                                                                     // 39\n  try {                                                                                                              // 40\n    // Not own constructor property must be Object                                                                   // 41\n    if ( obj.constructor &&                                                                                          // 42\n         !hasOwn.call(obj, \"constructor\") &&                                                                         // 43\n         !hasOwn.call(obj.constructor.prototype, \"isPrototypeOf\") ) {                                                // 44\n      return false;                                                                                                  // 45\n    }                                                                                                                // 46\n  } catch ( e ) {                                                                                                    // 47\n    // IE8,9 Will throw exceptions on certain host objects #9897                                                     // 48\n    return false;                                                                                                    // 49\n  }                                                                                                                  // 50\n                                                                                                                     // 51\n  // Support: IE<9                                                                                                   // 52\n  // Handle iteration over inherited properties before own properties.                                               // 53\n  if ( support.ownLast ) {                                                                                           // 54\n    for ( key in obj ) {                                                                                             // 55\n      return hasOwn.call( obj, key );                                                                                // 56\n    }                                                                                                                // 57\n  }                                                                                                                  // 58\n                                                                                                                     // 59\n  // Own properties are enumerated firstly, so to speed up,                                                          // 60\n  // if last one is own, then all properties are own.                                                                // 61\n  for ( key in obj ) {}                                                                                              // 62\n                                                                                                                     // 63\n  return key === undefined || hasOwn.call( obj, key );                                                               // 64\n};                                                                                                                   // 65\n                                                                                                                     // 66\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}}}}},{\"extensions\":[\".js\",\".json\"]});\nvar exports = require(\"./node_modules/meteor/check/match.js\");\n\n/* Exports */\nif (typeof Package === 'undefined') Package = {};\n(function (pkg, symbols) {\n  for (var s in symbols)\n    (s in pkg) || (pkg[s] = symbols[s]);\n})(Package.check = exports, {\n  check: check,\n  Match: Match\n});\n\n})();\n","servePath":"/packages/check.js","sourceMap":{"version":3,"sources":["/packages/check/match.js","/packages/check/isPlainObject.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2H;;;;;;;;;;;ACveA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0H","file":"/packages/check.js","sourcesContent":["// XXX docs\n\n// Things we explicitly do NOT support:\n//    - heterogenous arrays\n\nvar currentArgumentChecker = new Meteor.EnvironmentVariable;\nvar isPlainObject = require(\"./isPlainObject.js\").isPlainObject;\n\n/**\n * @summary Check that a value matches a [pattern](#matchpatterns).\n * If the value does not match the pattern, throw a `Match.Error`.\n *\n * Particularly useful to assert that arguments to a function have the right\n * types and structure.\n * @locus Anywhere\n * @param {Any} value The value to check\n * @param {MatchPattern} pattern The pattern to match\n * `value` against\n */\nvar check = exports.check = function (value, pattern) {\n  // Record that check got called, if somebody cared.\n  //\n  // We use getOrNullIfOutsideFiber so that it's OK to call check()\n  // from non-Fiber server contexts; the downside is that if you forget to\n  // bindEnvironment on some random callback in your method/publisher,\n  // it might not find the argumentChecker and you'll get an error about\n  // not checking an argument that it looks like you're checking (instead\n  // of just getting a \"Node code must run in a Fiber\" error).\n  var argChecker = currentArgumentChecker.getOrNullIfOutsideFiber();\n  if (argChecker)\n    argChecker.checking(value);\n  var result = testSubtree(value, pattern);\n  if (result) {\n    var err = new Match.Error(result.message);\n    if (result.path) {\n      err.message += \" in field \" + result.path;\n      err.path = result.path;\n    }\n    throw err;\n  }\n};\n\n/**\n * @namespace Match\n * @summary The namespace for all Match types and methods.\n */\nvar Match = exports.Match = {\n  Optional: function (pattern) {\n    return new Optional(pattern);\n  },\n  Maybe: function (pattern) {\n    return new Maybe(pattern);\n  },\n  OneOf: function (/*arguments*/) {\n    return new OneOf(_.toArray(arguments));\n  },\n  Any: ['__any__'],\n  Where: function (condition) {\n    return new Where(condition);\n  },\n  ObjectIncluding: function (pattern) {\n    return new ObjectIncluding(pattern);\n  },\n  ObjectWithValues: function (pattern) {\n    return new ObjectWithValues(pattern);\n  },\n  // Matches only signed 32-bit integers\n  Integer: ['__integer__'],\n\n  // XXX matchers should know how to describe themselves for errors\n  Error: Meteor.makeErrorType(\"Match.Error\", function (msg) {\n    this.message = \"Match error: \" + msg;\n    // The path of the value that failed to match. Initially empty, this gets\n    // populated by catching and rethrowing the exception as it goes back up the\n    // stack.\n    // E.g.: \"vals[3].entity.created\"\n    this.path = \"\";\n    // If this gets sent over DDP, don't give full internal details but at least\n    // provide something better than 500 Internal server error.\n    this.sanitizedError = new Meteor.Error(400, \"Match failed\");\n  }),\n\n  // Tests to see if value matches pattern. Unlike check, it merely returns true\n  // or false (unless an error other than Match.Error was thrown). It does not\n  // interact with _failIfArgumentsAreNotAllChecked.\n  // XXX maybe also implement a Match.match which returns more information about\n  //     failures but without using exception handling or doing what check()\n  //     does with _failIfArgumentsAreNotAllChecked and Meteor.Error conversion\n\n  /**\n   * @summary Returns true if the value matches the pattern.\n   * @locus Anywhere\n   * @param {Any} value The value to check\n   * @param {MatchPattern} pattern The pattern to match `value` against\n   */\n  test: function (value, pattern) {\n    return !testSubtree(value, pattern);\n  },\n\n  // Runs `f.apply(context, args)`. If check() is not called on every element of\n  // `args` (either directly or in the first level of an array), throws an error\n  // (using `description` in the message).\n  //\n  _failIfArgumentsAreNotAllChecked: function (f, context, args, description) {\n    var argChecker = new ArgumentChecker(args, description);\n    var result = currentArgumentChecker.withValue(argChecker, function () {\n      return f.apply(context, args);\n    });\n    // If f didn't itself throw, make sure it checked all of its arguments.\n    argChecker.throwUnlessAllArgumentsHaveBeenChecked();\n    return result;\n  }\n};\n\nvar Optional = function (pattern) {\n  this.pattern = pattern;\n};\n\nvar Maybe = function (pattern) {\n  this.pattern = pattern;\n};\n\nvar OneOf = function (choices) {\n  if (_.isEmpty(choices))\n    throw new Error(\"Must provide at least one choice to Match.OneOf\");\n  this.choices = choices;\n};\n\nvar Where = function (condition) {\n  this.condition = condition;\n};\n\nvar ObjectIncluding = function (pattern) {\n  this.pattern = pattern;\n};\n\nvar ObjectWithValues = function (pattern) {\n  this.pattern = pattern;\n};\n\nvar stringForErrorMessage = function (value, options) {\n  options = options || {};\n\n  if ( value === null ) return \"null\";\n\n  if ( options.onlyShowType ) {\n    return typeof value;\n  }\n\n  // Your average non-object things.  Saves from doing the try/catch below for.\n  if ( typeof value !== \"object\" ) {\n    return EJSON.stringify(value)\n  }\n\n  try {\n    // Find objects with circular references since EJSON doesn't support them yet (Issue #4778 + Unaccepted PR)\n    // If the native stringify is going to choke, EJSON.stringify is going to choke too.\n    JSON.stringify(value);\n  } catch (stringifyError) {\n    if ( stringifyError.name === \"TypeError\" ) {\n      return typeof value;\n    }\n  }\n\n  return EJSON.stringify(value);\n};\n\nvar typeofChecks = [\n  [String, \"string\"],\n  [Number, \"number\"],\n  [Boolean, \"boolean\"],\n  // While we don't allow undefined/function in EJSON, this is good for optional\n  // arguments with OneOf.\n  [Function, \"function\"],\n  [undefined, \"undefined\"]\n];\n\n// Return `false` if it matches. Otherwise, return an object with a `message` and a `path` field.\nvar testSubtree = function (value, pattern) {\n  // Match anything!\n  if (pattern === Match.Any)\n    return false;\n\n  // Basic atomic types.\n  // Do not match boxed objects (e.g. String, Boolean)\n  for (var i = 0; i < typeofChecks.length; ++i) {\n    if (pattern === typeofChecks[i][0]) {\n      if (typeof value === typeofChecks[i][1])\n        return false;\n      return {\n        message: \"Expected \" + typeofChecks[i][1] + \", got \" + stringForErrorMessage(value, { onlyShowType: true }),\n        path: \"\"\n      };\n    }\n  }\n\n  if (pattern === null) {\n    if (value === null) {\n      return false;\n    }\n    return {\n      message: \"Expected null, got \" + stringForErrorMessage(value),\n      path: \"\"\n    };\n  }\n\n  // Strings, numbers, and booleans match literally. Goes well with Match.OneOf.\n  if (typeof pattern === \"string\" || typeof pattern === \"number\" || typeof pattern === \"boolean\") {\n    if (value === pattern)\n      return false;\n    return {\n      message: \"Expected \" + pattern + \", got \" + stringForErrorMessage(value),\n      path: \"\"\n    };\n  }\n\n  // Match.Integer is special type encoded with array\n  if (pattern === Match.Integer) {\n    // There is no consistent and reliable way to check if variable is a 64-bit\n    // integer. One of the popular solutions is to get reminder of division by 1\n    // but this method fails on really large floats with big precision.\n    // E.g.: 1.348192308491824e+23 % 1 === 0 in V8\n    // Bitwise operators work consistantly but always cast variable to 32-bit\n    // signed integer according to JavaScript specs.\n    if (typeof value === \"number\" && (value | 0) === value)\n      return false;\n    return {\n      message: \"Expected Integer, got \" + stringForErrorMessage(value),\n      path: \"\"\n    };\n  }\n\n  // \"Object\" is shorthand for Match.ObjectIncluding({});\n  if (pattern === Object)\n    pattern = Match.ObjectIncluding({});\n\n  // Array (checked AFTER Any, which is implemented as an Array).\n  if (pattern instanceof Array) {\n    if (pattern.length !== 1) {\n      return {\n        message: \"Bad pattern: arrays must have one type element\" + stringForErrorMessage(pattern),\n        path: \"\"\n      };\n    }\n    if (!_.isArray(value) && !_.isArguments(value)) {\n      return {\n        message: \"Expected array, got \" + stringForErrorMessage(value),\n        path: \"\"\n      };\n    }\n\n    for (var i = 0, length = value.length; i < length; i++) {\n      var result = testSubtree(value[i], pattern[0]);\n      if (result) {\n        result.path = _prependPath(i, result.path);\n        return result;\n      }\n    }\n    return false;\n  }\n\n  // Arbitrary validation checks. The condition can return false or throw a\n  // Match.Error (ie, it can internally use check()) to fail.\n  if (pattern instanceof Where) {\n    var result;\n    try {\n      result = pattern.condition(value);\n    } catch (err) {\n      if (!(err instanceof Match.Error))\n        throw err;\n      return {\n        message: err.message,\n        path: err.path\n      };\n    }\n    if (result)\n      return false;\n    // XXX this error is terrible\n    return {\n      message: \"Failed Match.Where validation\",\n      path: \"\"\n    };\n  }\n\n\n  if (pattern instanceof Maybe) {\n    pattern = Match.OneOf(undefined, null, pattern.pattern);\n  }\n  else if (pattern instanceof Optional) {\n    pattern = Match.OneOf(undefined, pattern.pattern);\n  }\n\n  if (pattern instanceof OneOf) {\n    for (var i = 0; i < pattern.choices.length; ++i) {\n      var result = testSubtree(value, pattern.choices[i]);\n      if (!result) {\n        // No error? Yay, return.\n        return false;\n      }\n      // Match errors just mean try another choice.\n    }\n    // XXX this error is terrible\n    return {\n      message: \"Failed Match.OneOf, Match.Maybe or Match.Optional validation\",\n      path: \"\"\n    };\n  }\n\n  // A function that isn't something we special-case is assumed to be a\n  // constructor.\n  if (pattern instanceof Function) {\n    if (value instanceof pattern)\n      return false;\n    return {\n      message: \"Expected \" + (pattern.name ||\"particular constructor\"),\n      path: \"\"\n    };\n  }\n\n  var unknownKeysAllowed = false;\n  var unknownKeyPattern;\n  if (pattern instanceof ObjectIncluding) {\n    unknownKeysAllowed = true;\n    pattern = pattern.pattern;\n  }\n  if (pattern instanceof ObjectWithValues) {\n    unknownKeysAllowed = true;\n    unknownKeyPattern = [pattern.pattern];\n    pattern = {};  // no required keys\n  }\n\n  if (typeof pattern !== \"object\") {\n    return {\n      message: \"Bad pattern: unknown pattern type\",\n      path: \"\"\n    };\n  }\n\n  // An object, with required and optional keys. Note that this does NOT do\n  // structural matches against objects of special types that happen to match\n  // the pattern: this really needs to be a plain old {Object}!\n  if (typeof value !== 'object') {\n    return {\n      message: \"Expected object, got \" + typeof value,\n      path: \"\"\n    };\n  }\n  if (value === null) {\n    return {\n      message: \"Expected object, got null\",\n      path: \"\"\n    };\n  }\n  if (! isPlainObject(value)) {\n    return {\n      message: \"Expected plain object\",\n      path: \"\"\n    };\n  }\n\n  var requiredPatterns = {};\n  var optionalPatterns = {};\n  _.each(pattern, function (subPattern, key) {\n    if (subPattern instanceof Optional || subPattern instanceof Maybe)\n      optionalPatterns[key] = subPattern.pattern;\n    else\n      requiredPatterns[key] = subPattern;\n  });\n\n  //XXX: replace with underscore's _.allKeys if Meteor updates underscore to 1.8+ (or lodash)\n  var allKeys = function(obj){\n    var keys = [];\n    if (_.isObject(obj)){\n      for (var key in obj) keys.push(key);\n    }\n    return keys;\n  }\n\n  for (var keys = allKeys(value), i = 0, length = keys.length; i < length; i++) {\n    var key = keys[i];\n    var subValue = value[key];\n    if (_.has(requiredPatterns, key)) {\n      var result = testSubtree(subValue, requiredPatterns[key]);\n      if (result) {\n        result.path = _prependPath(key, result.path);\n        return result;\n      }\n      delete requiredPatterns[key];\n    } else if (_.has(optionalPatterns, key)) {\n      var result = testSubtree(subValue, optionalPatterns[key]);\n      if (result) {\n        result.path = _prependPath(key, result.path);\n        return result;\n      }\n    } else {\n      if (!unknownKeysAllowed) {\n        return {\n          message: \"Unknown key\",\n          path: key\n        };\n      }\n      if (unknownKeyPattern) {\n        var result = testSubtree(subValue, unknownKeyPattern[0]);\n        if (result) {\n          result.path = _prependPath(key, result.path);\n          return result;\n        }\n      }\n    }\n  }\n\n  var keys = _.keys(requiredPatterns);\n  if (keys.length) {\n    return {\n      message: \"Missing key '\" + keys[0] + \"'\",\n      path: \"\"\n    };\n  }\n};\n\nvar ArgumentChecker = function (args, description) {\n  var self = this;\n  // Make a SHALLOW copy of the arguments. (We'll be doing identity checks\n  // against its contents.)\n  self.args = _.clone(args);\n  // Since the common case will be to check arguments in order, and we splice\n  // out arguments when we check them, make it so we splice out from the end\n  // rather than the beginning.\n  self.args.reverse();\n  self.description = description;\n};\n\n_.extend(ArgumentChecker.prototype, {\n  checking: function (value) {\n    var self = this;\n    if (self._checkingOneValue(value))\n      return;\n    // Allow check(arguments, [String]) or check(arguments.slice(1), [String])\n    // or check([foo, bar], [String]) to count... but only if value wasn't\n    // itself an argument.\n    if (_.isArray(value) || _.isArguments(value)) {\n      _.each(value, _.bind(self._checkingOneValue, self));\n    }\n  },\n  _checkingOneValue: function (value) {\n    var self = this;\n    for (var i = 0; i < self.args.length; ++i) {\n      // Is this value one of the arguments? (This can have a false positive if\n      // the argument is an interned primitive, but it's still a good enough\n      // check.)\n      // (NaN is not === to itself, so we have to check specially.)\n      if (value === self.args[i] || (_.isNaN(value) && _.isNaN(self.args[i]))) {\n        self.args.splice(i, 1);\n        return true;\n      }\n    }\n    return false;\n  },\n  throwUnlessAllArgumentsHaveBeenChecked: function () {\n    var self = this;\n    if (!_.isEmpty(self.args))\n      throw new Error(\"Did not check() all arguments during \" +\n                      self.description);\n  }\n});\n\nvar _jsKeywords = [\"do\", \"if\", \"in\", \"for\", \"let\", \"new\", \"try\", \"var\", \"case\",\n  \"else\", \"enum\", \"eval\", \"false\", \"null\", \"this\", \"true\", \"void\", \"with\",\n  \"break\", \"catch\", \"class\", \"const\", \"super\", \"throw\", \"while\", \"yield\",\n  \"delete\", \"export\", \"import\", \"public\", \"return\", \"static\", \"switch\",\n  \"typeof\", \"default\", \"extends\", \"finally\", \"package\", \"private\", \"continue\",\n  \"debugger\", \"function\", \"arguments\", \"interface\", \"protected\", \"implements\",\n  \"instanceof\"];\n\n// Assumes the base of path is already escaped properly\n// returns key + base\nvar _prependPath = function (key, base) {\n  if ((typeof key) === \"number\" || key.match(/^[0-9]+$/))\n    key = \"[\" + key + \"]\";\n  else if (!key.match(/^[a-z_$][0-9a-z_$]*$/i) || _.contains(_jsKeywords, key))\n    key = JSON.stringify([key]);\n\n  if (base && base[0] !== \"[\")\n    return key + '.' + base;\n  return key + base;\n};\n\n","// Copy of jQuery.isPlainObject for the server side from jQuery v1.11.2.\n\nvar class2type = {};\n\nvar toString = class2type.toString;\n\nvar hasOwn = class2type.hasOwnProperty;\n\nvar support = {};\n\n// Populate the class2type map\n_.each(\"Boolean Number String Function Array Date RegExp Object Error\".split(\" \"), function(name, i) {\n  class2type[ \"[object \" + name + \"]\" ] = name.toLowerCase();\n});\n\nfunction type( obj ) {\n  if ( obj == null ) {\n    return obj + \"\";\n  }\n  return typeof obj === \"object\" || typeof obj === \"function\" ?\n    class2type[ toString.call(obj) ] || \"object\" :\n    typeof obj;\n}\n\nfunction isWindow( obj ) {\n  /* jshint eqeqeq: false */\n  return obj != null && obj == obj.window;\n}\n\nexports.isPlainObject = function( obj ) {\n  var key;\n\n  // Must be an Object.\n  // Because of IE, we also have to check the presence of the constructor property.\n  // Make sure that DOM nodes and window objects don't pass through, as well\n  if ( !obj || type(obj) !== \"object\" || obj.nodeType || isWindow( obj ) ) {\n    return false;\n  }\n\n  try {\n    // Not own constructor property must be Object\n    if ( obj.constructor &&\n         !hasOwn.call(obj, \"constructor\") &&\n         !hasOwn.call(obj.constructor.prototype, \"isPrototypeOf\") ) {\n      return false;\n    }\n  } catch ( e ) {\n    // IE8,9 Will throw exceptions on certain host objects #9897\n    return false;\n  }\n\n  // Support: IE<9\n  // Handle iteration over inherited properties before own properties.\n  if ( support.ownLast ) {\n    for ( key in obj ) {\n      return hasOwn.call( obj, key );\n    }\n  }\n\n  // Own properties are enumerated firstly, so to speed up,\n  // if last one is own, then all properties are own.\n  for ( key in obj ) {}\n\n  return key === undefined || hasOwn.call( obj, key );\n};\n"]}}]