[{"type":"js","data":"(function () {\n\n/* Imports */\nvar Meteor = Package.meteor.Meteor;\nvar global = Package.meteor.global;\nvar meteorEnv = Package.meteor.meteorEnv;\nvar ECMAScript = Package.ecmascript.ECMAScript;\nvar _ = Package.underscore._;\nvar meteorInstall = Package.modules.meteorInstall;\nvar Buffer = Package.modules.Buffer;\nvar process = Package.modules.process;\nvar Symbol = Package['ecmascript-runtime'].Symbol;\nvar Map = Package['ecmascript-runtime'].Map;\nvar Set = Package['ecmascript-runtime'].Set;\nvar meteorBabelHelpers = Package['babel-runtime'].meteorBabelHelpers;\nvar Promise = Package.promise.Promise;\n\n/* Package-scope variables */\nvar WebAppHashing;\n\nvar require = meteorInstall({\"node_modules\":{\"meteor\":{\"webapp-hashing\":{\"webapp-hashing.js\":function(require){\n\n//////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                              //\n// packages/webapp-hashing/webapp-hashing.js                                                    //\n//                                                                                              //\n//////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                //\nvar crypto = Npm.require(\"crypto\");                                                             // 1\n                                                                                                //\nWebAppHashing = {};                                                                             // 3\n                                                                                                //\n// Calculate a hash of all the client resources downloaded by the                               //\n// browser, including the application HTML, runtime config, code, and                           //\n// static files.                                                                                //\n//                                                                                              //\n// This hash *must* change if any resources seen by the browser                                 //\n// change, and ideally *doesn't* change for any server-only changes                             //\n// (but the second is a performance enhancement, not a hard                                     //\n// requirement).                                                                                //\n                                                                                                //\nWebAppHashing.calculateClientHash = function (manifest, includeFilter, runtimeConfigOverride) {\n  var hash = crypto.createHash('sha1');                                                         // 16\n                                                                                                //\n  // Omit the old hashed client values in the new hash. These may be                            //\n  // modified in the new boilerplate.                                                           //\n  var runtimeCfg = _.omit(__meteor_runtime_config__, ['autoupdateVersion', 'autoupdateVersionRefreshable', 'autoupdateVersionCordova']);\n                                                                                                //\n  if (runtimeConfigOverride) {                                                                  // 24\n    runtimeCfg = runtimeConfigOverride;                                                         // 25\n  }                                                                                             // 26\n                                                                                                //\n  hash.update(JSON.stringify(runtimeCfg, 'utf8'));                                              // 28\n                                                                                                //\n  _.each(manifest, function (resource) {                                                        // 30\n    if ((!includeFilter || includeFilter(resource.type)) && (resource.where === 'client' || resource.where === 'internal')) {\n      hash.update(resource.path);                                                               // 33\n      hash.update(resource.hash);                                                               // 34\n    }                                                                                           // 35\n  });                                                                                           // 36\n  return hash.digest('hex');                                                                    // 37\n};                                                                                              // 38\n                                                                                                //\nWebAppHashing.calculateCordovaCompatibilityHash = function (platformVersion, pluginVersions) {  // 40\n  var hash = crypto.createHash('sha1');                                                         // 42\n                                                                                                //\n  hash.update(platformVersion);                                                                 // 44\n                                                                                                //\n  // Sort plugins first so iteration order doesn't affect the hash                              //\n  var plugins = Object.keys(pluginVersions).sort();                                             // 47\n  for (var _iterator = plugins, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {\n    var _ref;                                                                                   // 48\n                                                                                                //\n    if (_isArray) {                                                                             // 48\n      if (_i >= _iterator.length) break;                                                        // 48\n      _ref = _iterator[_i++];                                                                   // 48\n    } else {                                                                                    // 48\n      _i = _iterator.next();                                                                    // 48\n      if (_i.done) break;                                                                       // 48\n      _ref = _i.value;                                                                          // 48\n    }                                                                                           // 48\n                                                                                                //\n    var plugin = _ref;                                                                          // 48\n                                                                                                //\n    var version = pluginVersions[plugin];                                                       // 49\n    hash.update(plugin);                                                                        // 50\n    hash.update(version);                                                                       // 51\n  }                                                                                             // 52\n                                                                                                //\n  return hash.digest('hex');                                                                    // 54\n};                                                                                              // 55\n//////////////////////////////////////////////////////////////////////////////////////////////////\n\n}}}}},{\"extensions\":[\".js\",\".json\"]});\nrequire(\"./node_modules/meteor/webapp-hashing/webapp-hashing.js\");\n\n/* Exports */\nif (typeof Package === 'undefined') Package = {};\n(function (pkg, symbols) {\n  for (var s in symbols)\n    (s in pkg) || (pkg[s] = symbols[s]);\n})(Package['webapp-hashing'] = {}, {\n  WebAppHashing: WebAppHashing\n});\n\n})();\n","servePath":"/packages/webapp-hashing.js","sourceMap":{"version":3,"sources":["/packages/webapp-hashing/webapp-hashing.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,IAAI,SAAS,IAAI,OAAJ,CAAY,QAAZ,CAAb;;AAEA,gBAAgB,EAAhB;;;;;;;;;;;AAWA,cAAc,mBAAd,GACE,UAAU,QAAV,EAAoB,aAApB,EAAmC,qBAAnC,EAA0D;AAC1D,MAAI,OAAO,OAAO,UAAP,CAAkB,MAAlB,CAAX;;;;AAIA,MAAI,aAAa,EAAE,IAAF,CAAO,yBAAP,EACf,CAAC,mBAAD,EAAsB,8BAAtB,EACC,0BADD,CADe,CAAjB;;AAIA,MAAI,qBAAJ,EAA2B;AACzB,iBAAa,qBAAb;AACD;;AAED,OAAK,MAAL,CAAY,KAAK,SAAL,CAAe,UAAf,EAA2B,MAA3B,CAAZ;;AAEA,IAAE,IAAF,CAAO,QAAP,EAAiB,UAAU,QAAV,EAAoB;AACjC,QAAI,CAAC,CAAE,aAAF,IAAmB,cAAc,SAAS,IAAvB,CAApB,MACC,SAAS,KAAT,KAAmB,QAAnB,IAA+B,SAAS,KAAT,KAAmB,UADnD,CAAJ,EACoE;AACpE,WAAK,MAAL,CAAY,SAAS,IAArB;AACA,WAAK,MAAL,CAAY,SAAS,IAArB;AACD;AACF,GAND;AAOA,SAAO,KAAK,MAAL,CAAY,KAAZ,CAAP;AACD,CAxBD;;AA0BA,cAAc,iCAAd,GACE,UAAS,eAAT,EAA0B,cAA1B,EAA0C;AAC1C,MAAM,OAAO,OAAO,UAAP,CAAkB,MAAlB,CAAb;;AAEA,OAAK,MAAL,CAAY,eAAZ;;;AAGA,MAAM,UAAU,OAAO,IAAP,CAAY,cAAZ,EAA4B,IAA5B,EAAhB;AACA,uBAAmB,OAAnB,kHAA4B;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA,QAAnB,MAAmB;;AAC1B,QAAM,UAAU,eAAe,MAAf,CAAhB;AACA,SAAK,MAAL,CAAY,MAAZ;AACA,SAAK,MAAL,CAAY,OAAZ;AACD;;AAED,SAAO,KAAK,MAAL,CAAY,KAAZ,CAAP;AACD,CAfD,oG","file":"/packages/webapp-hashing.js","sourcesContent":["var crypto = Npm.require(\"crypto\");\n\nWebAppHashing = {};\n\n// Calculate a hash of all the client resources downloaded by the\n// browser, including the application HTML, runtime config, code, and\n// static files.\n//\n// This hash *must* change if any resources seen by the browser\n// change, and ideally *doesn't* change for any server-only changes\n// (but the second is a performance enhancement, not a hard\n// requirement).\n\nWebAppHashing.calculateClientHash =\n  function (manifest, includeFilter, runtimeConfigOverride) {\n  var hash = crypto.createHash('sha1');\n\n  // Omit the old hashed client values in the new hash. These may be\n  // modified in the new boilerplate.\n  var runtimeCfg = _.omit(__meteor_runtime_config__,\n    ['autoupdateVersion', 'autoupdateVersionRefreshable',\n     'autoupdateVersionCordova']);\n\n  if (runtimeConfigOverride) {\n    runtimeCfg = runtimeConfigOverride;\n  }\n\n  hash.update(JSON.stringify(runtimeCfg, 'utf8'));\n\n  _.each(manifest, function (resource) {\n      if ((! includeFilter || includeFilter(resource.type)) &&\n          (resource.where === 'client' || resource.where === 'internal')) {\n      hash.update(resource.path);\n      hash.update(resource.hash);\n    }\n  });\n  return hash.digest('hex');\n};\n\nWebAppHashing.calculateCordovaCompatibilityHash =\n  function(platformVersion, pluginVersions) {\n  const hash = crypto.createHash('sha1');\n\n  hash.update(platformVersion);\n\n  // Sort plugins first so iteration order doesn't affect the hash\n  const plugins = Object.keys(pluginVersions).sort();\n  for (let plugin of plugins) {\n    const version = pluginVersions[plugin];\n    hash.update(plugin);\n    hash.update(version);\n  }\n\n  return hash.digest('hex');\n};\n"]}}]