{"version":3,"sources":["meteor://ðŸ’»app/packages/babel-compiler/babel.js","meteor://ðŸ’»app/packages/babel-compiler/babel-compiler.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;AC/BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"/packages/babel-compiler.js","sourcesContent":["var meteorBabel = Npm.require('meteor-babel');\n\n/**\n * Returns a new object containing default options appropriate for\n */\nfunction getDefaultOptions(extraFeatures) {\n  // See https://github.com/meteor/babel/blob/master/options.js for more\n  // information about what the default options are.\n  var options = meteorBabel.getDefaultOptions(extraFeatures);\n\n  // The sourceMap option should probably be removed from the default\n  // options returned by meteorBabel.getDefaultOptions.\n  delete options.sourceMap;\n\n  return options;\n}\n\nBabel = {\n  getDefaultOptions: getDefaultOptions,\n\n  // Deprecated, now a no-op.\n  validateExtraFeatures: Function.prototype,\n\n  compile: function (source, options) {\n    options = options || getDefaultOptions();\n    return meteorBabel.compile(source, options);\n  },\n\n  setCacheDir: function (cacheDir) {\n    meteorBabel.setCacheDir(cacheDir);\n  }\n};\n","/**\n * A compiler that can be instantiated with features and used inside\n * Plugin.registerCompiler\n * @param {Object} extraFeatures The same object that getDefaultOptions takes\n */\nBabelCompiler = function BabelCompiler(extraFeatures) {\n  this.extraFeatures = extraFeatures;\n  this._babelrcCache = null;\n  this._babelrcWarnings = Object.create(null);\n};\n\nvar BCp = BabelCompiler.prototype;\nvar excludedFileExtensionPattern = /\\.es5\\.js$/i;\nvar hasOwn = Object.prototype.hasOwnProperty;\n\nBCp.processFilesForTarget = function (inputFiles) {\n  // Reset this cache for each batch processed.\n  this._babelrcCache = null;\n\n  inputFiles.forEach(function (inputFile) {\n    var toBeAdded = this.processOneFileForTarget(inputFile);\n    if (toBeAdded) {\n      inputFile.addJavaScript(toBeAdded);\n    }\n  }, this);\n};\n\n// Returns an object suitable for passing to inputFile.addJavaScript, or\n// null to indicate there was an error, and nothing should be added.\nBCp.processOneFileForTarget = function (inputFile, source) {\n  this._babelrcCache = this._babelrcCache || Object.create(null);\n\n  if (typeof source !== \"string\") {\n    // Other compiler plugins can call processOneFileForTarget with a\n    // source string that's different from inputFile.getContentsAsString()\n    // if they've already done some processing.\n    source = inputFile.getContentsAsString();\n  }\n\n  var packageName = inputFile.getPackageName();\n  var inputFilePath = inputFile.getPathInPackage();\n  var outputFilePath = inputFilePath;\n  var fileOptions = inputFile.getFileOptions();\n  var toBeAdded = {\n    sourcePath: inputFilePath,\n    path: outputFilePath,\n    data: source,\n    hash: inputFile.getSourceHash(),\n    sourceMap: null,\n    bare: !! fileOptions.bare\n  };\n  var cacheDeps = {\n    sourceHash: toBeAdded.hash\n  };\n\n  // If you need to exclude a specific file within a package from Babel\n  // compilation, pass the { transpile: false } options to api.addFiles\n  // when you add that file.\n  if (fileOptions.transpile !== false &&\n      // Bare files should not be transpiled by Babel, because they do not\n      // have access to CommonJS APIs like `require`, `module`, `exports`.\n      ! toBeAdded.bare &&\n      // If you need to exclude a specific file within an app from Babel\n      // compilation, give it the following file extension: .es5.js\n      ! excludedFileExtensionPattern.test(inputFilePath)) {\n\n    var targetCouldBeInternetExplorer8 =\n      inputFile.getArch() === \"web.browser\";\n\n    var extraFeatures = Object.assign({}, this.extraFeatures);\n\n    if (! extraFeatures.hasOwnProperty(\"jscript\")) {\n      // Perform some additional transformations to improve compatibility\n      // in older browsers (e.g. wrapping named function expressions, per\n      // http://kiro.me/blog/nfe_dilemma.html).\n      extraFeatures.jscript = targetCouldBeInternetExplorer8;\n    }\n\n    if (inputFile.isPackageFile()) {\n      // When compiling package files, handle import/export syntax using\n      // the official Babel plugin, so that package authors won't publish\n      // code that relies on module.import and module.export, because such\n      // code would fail on Meteor versions before 1.3.3.  When compiling\n      // application files, however, it's fine to rely on module.import\n      // and module.export, and the developer experience will be much\n      // better for it: faster compilation, real variables, import\n      // statements inside conditional statements, etc.\n      //\n      // TODO Remove this once we are confident enough developers have\n      // updated to a version of Meteor that supports module.import and\n      // module.export.\n      extraFeatures.legacyModules = true;\n    }\n\n    var babelOptions = Babel.getDefaultOptions(extraFeatures);\n\n    this.inferExtraBabelOptions(inputFile, babelOptions, cacheDeps);\n\n    babelOptions.sourceMap = true;\n    babelOptions.filename =\n      babelOptions.sourceFileName = packageName\n      ? \"/packages/\" + packageName + \"/\" + inputFilePath\n      : \"/\" + inputFilePath;\n\n    babelOptions.sourceMapTarget = babelOptions.filename + \".map\";\n\n    try {\n      var result = profile('Babel.compile', function () {\n        return Babel.compile(source, babelOptions, cacheDeps);\n      });\n    } catch (e) {\n      if (e.loc) {\n        inputFile.error({\n          message: e.message,\n          line: e.loc.line,\n          column: e.loc.column,\n        });\n\n        return null;\n      }\n\n      throw e;\n    }\n\n    toBeAdded.data = result.code;\n    toBeAdded.hash = result.hash;\n    toBeAdded.sourceMap = result.map;\n  }\n\n  return toBeAdded;\n};\n\nBCp.setDiskCacheDirectory = function (cacheDir) {\n  Babel.setCacheDir(cacheDir);\n};\n\nfunction profile(name, func) {\n  if (typeof Profile !== 'undefined') {\n    return Profile.time(name, func);\n  } else {\n    return func();\n  }\n};\n\nBCp.inferExtraBabelOptions = function (inputFile, babelOptions, cacheDeps) {\n  if (! inputFile.require ||\n      ! inputFile.findControlFile ||\n      ! inputFile.readAndWatchFile) {\n    return false;\n  }\n\n  return (\n    // If a .babelrc exists, it takes precedence over package.json.\n    this._inferFromBabelRc(inputFile, babelOptions, cacheDeps) ||\n    this._inferFromPackageJson(inputFile, babelOptions, cacheDeps)\n  );\n};\n\nBCp._inferFromBabelRc = function (inputFile, babelOptions, cacheDeps) {\n  var babelrcPath = inputFile.findControlFile(\".babelrc\");\n  if (babelrcPath) {\n    if (! hasOwn.call(this._babelrcCache, babelrcPath)) {\n      this._babelrcCache[babelrcPath] =\n        JSON.parse(inputFile.readAndWatchFile(babelrcPath));\n    }\n\n    return this._inferHelper(\n      inputFile,\n      babelOptions,\n      babelrcPath,\n      this._babelrcCache[babelrcPath],\n      cacheDeps\n    );\n  }\n};\n\nBCp._inferFromPackageJson = function (inputFile, babelOptions, cacheDeps) {\n  var pkgJsonPath = inputFile.findControlFile(\"package.json\");\n  if (pkgJsonPath) {\n    if (! hasOwn.call(this._babelrcCache, pkgJsonPath)) {\n      this._babelrcCache[pkgJsonPath] = JSON.parse(\n        inputFile.readAndWatchFile(pkgJsonPath)\n      ).babel || null;\n    }\n\n    return this._inferHelper(\n      inputFile,\n      babelOptions,\n      pkgJsonPath,\n      this._babelrcCache[pkgJsonPath],\n      cacheDeps\n    );\n  }\n};\n\nBCp._inferHelper = function (\n  inputFile,\n  babelOptions,\n  controlFilePath,\n  babelrc,\n  cacheDeps\n) {\n  if (! babelrc) {\n    return false;\n  }\n\n  var compiler = this;\n  var inferredPresets = [];\n  var result;\n\n  function infer(listName, prefix) {\n    var list = babelrc[listName];\n    if (! Array.isArray(list) || list.length === 0) {\n      return;\n    }\n\n    function req(id) {\n      try {\n        return reqMightThrow(id);\n      } catch (e) {\n        if (e.code !== \"MODULE_NOT_FOUND\") {\n          throw e;\n        }\n\n        if (! hasOwn.call(compiler._babelrcWarnings, id)) {\n          compiler._babelrcWarnings[id] = controlFilePath;\n\n          console.error(\n            \"Warning: unable to resolve \" +\n              JSON.stringify(id) +\n              \" in \" + listName +\n              \" of \" + controlFilePath\n          );\n        }\n\n        return null;\n      }\n    }\n\n    function reqMightThrow(id) {\n      var isTopLevel = \"./\".indexOf(id.charAt(0)) < 0;\n      var presetOrPlugin;\n      var presetOrPluginMeta;\n\n      if (isTopLevel) {\n        try {\n          // If the identifier is top-level, try to prefix it with\n          // \"babel-plugin-\" or \"babel-preset-\".\n          presetOrPlugin = inputFile.require(prefix + id);\n          presetOrPluginMeta = inputFile.require(\n            packageNameFromTopLevelModuleId(prefix + id) + '/package.json');\n        } catch (e) {\n          if (e.code !== \"MODULE_NOT_FOUND\") {\n            throw e;\n          }\n          // Fall back to requiring the plugin as-is if the prefix failed.\n          presetOrPlugin = inputFile.require(id);\n          presetOrPluginMeta = inputFile.require(\n            packageNameFromTopLevelModuleId(id) + '/package.json');\n        }\n\n      } else {\n        // If the identifier is not top-level, but relative or absolute,\n        // then it will be required as-is, so that you can implement your\n        // own Babel plugins locally, rather than always using plugins\n        // installed from npm.\n        presetOrPlugin = inputFile.require(id, controlFilePath);\n\n        // Note that inputFile.readAndWatchFileWithHash converts module\n        // identifers to OS-specific paths if necessary.\n        var absId = inputFile.resolve(id, controlFilePath);\n        var info = inputFile.readAndWatchFileWithHash(absId);\n\n        presetOrPluginMeta = {\n          name: absId,\n          version: info.hash\n        };\n      }\n\n      return {\n        name: presetOrPluginMeta.name,\n        version: presetOrPluginMeta.version,\n        module: presetOrPlugin.__esModule\n          ? presetOrPlugin.default\n          : presetOrPlugin\n      };\n    }\n\n    var filtered = [];\n\n    list.forEach(function (item, i) {\n      if (typeof item === \"string\") {\n        result = req(item);\n        if (! result) return;\n        item = result.module;\n        cacheDeps[result.name] = result.version;\n      } else if (Array.isArray(item) &&\n                 typeof item[0] === \"string\") {\n        item = item.slice(); // defensive copy\n        result = req(item[0]);\n        if (! result) return;\n        item[0] = result.module;\n        cacheDeps[result.name] = result.version;\n      }\n      // else, an object { presets: [], plugins: [] } from meteorBabel, whose\n      // version is used for the cache hash internally.\n\n      filtered.push(item);\n    });\n\n    if (listName === \"plugins\") {\n      // Turn any additional plugins into their own preset, so that they\n      // can come before babel-preset-meteor.\n      inferredPresets.push({ plugins: filtered });\n    } else if (listName === \"presets\") {\n      inferredPresets.push.apply(inferredPresets, filtered);\n    }\n  }\n\n  infer(\"presets\", \"babel-preset-\");\n  infer(\"plugins\", \"babel-plugin-\");\n\n  if (inferredPresets.length > 0) {\n    babelOptions.presets.push.apply(\n      babelOptions.presets,\n      inferredPresets\n    );\n\n    return true;\n  }\n\n  return false;\n};\n\n// 'react-hot-loader/babel' => 'react-hot-loader'\nfunction packageNameFromTopLevelModuleId(id) {\n  return id.split(\"/\", 1)[0];\n}\n"]}